<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ruleset xmlns="http://pmd.sf.net/ruleset/1.0.0" 
		name="nemeses_pmd" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd" 
		xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd">
		
	<description>Java PMD ruleset</description>
	
	<exclude-pattern>.*/generated-sources/.*</exclude-pattern>
	<exclude-pattern>.*/Generated/.*</exclude-pattern>
	<exclude-pattern>.*/gensrc/.*</exclude-pattern>
	<exclude-pattern>.*/jsp/.*</exclude-pattern>
	<exclude-pattern>.*_jsp.java</exclude-pattern>
	<exclude-pattern>.*/jax-doclets/.*</exclude-pattern>
	
	<!-- Rules taken from the PMD (4.2.5) 'basic.xml' ruleset -->
	
    <rule name="EmptyCatchBlock"
    		 since="0.1"
          message="Avoid empty catch blocks"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyCatchBlock">
      <description>
Empty Catch Block finds instances where an exception is caught,
but nothing is done.  In most circumstances, this swallows an exception
which should either be acted on or reported.
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//CatchStatement
 [count(Block/BlockStatement) = 0 and ($allowCommentedBlocks != 'true' or Block/@containsComment = 'false')]
 [FormalParameter/Type/ReferenceType
   /ClassOrInterfaceType[@Image != 'InterruptedException' and @Image != 'CloneNotSupportedException']
 ]
 ]]>
             </value>
          </property>
          <property name="allowCommentedBlocks" description="Empty blocks containing comments will be skipped">
              <value>true</value>
          </property>
      </properties>
      <example>
  <![CDATA[
public void doSomething() {
  try {
    FileInputStream fis = new FileInputStream("/tmp/bugger");
  } catch (IOException ioe) {
      // not good
  }
}
 ]]>
      </example>
    </rule>

    <rule name="EmptyIfStmt"
    		 since="0.1"
          message="Avoid empty 'if' statements"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyIfStmt">
      <description>
Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
        <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//IfStatement/Statement
 [EmptyStatement or Block[count(*) = 0]]
 ]]>
              </value>
          </property>
      </properties>
      <example>
    <![CDATA[
public class Foo {
 void bar(int x) {
  if (x == 0) {
   // empty!
  }
 }
}
 ]]>
       </example>
    </rule>
	
    <rule name="EmptyWhileStmt"
    		 since="0.2"
          message="Avoid empty 'while' statements"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyWhileStmt">
       <description>
Empty While Statement finds all instances where a while statement
does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
       <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//WhileStatement/Statement[./Block[count(*) = 0]  or ./EmptyStatement]
]]>
              </value>
          </property>
      </properties>
       <example>
  <![CDATA[
public class Foo {
 void bar(int a, int b) {
  while (a == b) {
   // empty!
  }
 }
}
 ]]>
       </example>
    </rule>

    <rule name="EmptyTryBlock"
    		 since="0.4"
          message="Avoid empty try blocks"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyTryBlock">
      <description>
Avoid empty try blocks - what's the point?
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//TryStatement/Block[1][count(*) = 0]
]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 public void bar() {
  try {
  } catch (Exception e) {
    e.printStackTrace();
  }
 }
}
]]>
      </example>
    </rule>

    <rule name="EmptyFinallyBlock"
    		 since="0.4"
          message="Avoid empty finally blocks"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyFinallyBlock">
      <description>
Avoid empty finally blocks - these can be deleted.
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//FinallyStatement[count(Block/BlockStatement) = 0]
 ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 public void bar() {
  try {
    int x=2;
   } finally {
    // empty!
   }
 }
}
 ]]>
      </example>
    </rule>

    <rule name="EmptySwitchStatements"
    		 since="1.0"
          message="Avoid empty switch statements"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptySwitchStatements">
      <description>
Avoid empty switch statements.
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//SwitchStatement[count(*) = 1]
 ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   // once there was code here
   // but it's been commented out or something
  }
 }
}]]>
      </example>
    </rule>
    <rule name="JumbledIncrementer"
    		since="1.0"
         message="Avoid modifying an outer loop incrementer in an inner loop for update expression"
         class="net.sourceforge.pmd.rules.XPathRule"
         externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#JumbledIncrementer">
     <description>
Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.
     </description>
     <priority>2</priority>
     <properties>
         <property name="xpath">
             <value>
 <![CDATA[
//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
 ]]>
             </value>
         </property>
     </properties>
     <example>
 <![CDATA[
public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
 ]]>
     </example>
     </rule>


    <rule name="ForLoopShouldBeWhileLoop"
    		 since="1.02"
          message="This for loop could be simplified to a while loop"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ForLoopShouldBeWhileLoop">
      <description>
Some for loops can be simplified to while loops - this makes them more concise.
      </description>
      <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//ForStatement
 [count(*) > 1]
 [not(ForInit)]
 [not(ForUpdate)]
 [not(Type and Expression and Statement)]
 ]]>
            </value>
        </property>
    </properties>
      <example>
  <![CDATA[
public class Foo {
 void bar() {
  for (;true;) true; // No Init or Update part, may as well be: while (true)
 }
}
 ]]>
      </example>
    </rule>

    <rule name="UnnecessaryConversionTemporary"
    		 since="0.1"
          message="Avoid unnecessary temporaries when converting primitives to Strings"
          class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporary"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryConversionTemporary">
      <description>
Avoid unnecessary temporaries when converting primitives to Strings
      </description>
        <priority>2</priority>
      <example>
  <![CDATA[
public String convert(int x) {
  // this wastes an object
  String foo = new Integer(x).toString();
  // this is better
  return Integer.toString(x);
}
 ]]>
      </example>
    </rule>

	
    <rule name="OverrideBothEqualsAndHashcode"
    		 since="0.4"
          message="Ensure you override both equals() and hashCode()"
          class="net.sourceforge.pmd.rules.OverrideBothEqualsAndHashcode"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#OverrideBothEqualsAndHashcode">
      <description>
Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
// this is bad
public class Bar {
  public boolean equals(Object o) {
      // do some comparison
  }
}

// and so is this
public class Baz {
  public int hashCode() {
      // return some hash value
  }
}

// this is OK
public class Foo {
  public boolean equals(Object other) {
      // do some comparison
  }
  public int hashCode() {
      // return some hash value
  }
}
 ]]>
      </example>
    </rule>
	
    <rule name="DoubleCheckedLocking"
    		 since="1.04"
          message="Double checked locking is not thread safe in Java."
          class="net.sourceforge.pmd.rules.DoubleCheckedLocking"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#DoubleCheckedLocking">
      <description>
Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
An optimizing JRE may assign a reference to the baz variable before it creates the object the
  reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
public class Foo {
  Object baz;
  Object bar() {
    if(baz == null) { //baz may be non-null yet not fully created
      synchronized(this){
        if(baz == null){
          baz = new Object();
        }
      }
    }
    return baz;
  }
}
 ]]>
      </example>
    </rule>
	
	
    <rule name="ReturnFromFinallyBlock"
    		 since="1.05"
          message="Avoid returning from a finally block"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ReturnFromFinallyBlock">
      <description>
Avoid returning from a finally block - this can discard exceptions.
      </description>
      <priority>1</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//FinallyStatement//ReturnStatement
]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Bar {
 public String foo() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}
]]>
      </example>
    </rule>
	
	
    <rule name="EmptySynchronizedBlock"
    		 since="1.3"
          message="Avoid empty synchronized blocks"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptySynchronizedBlock">
      <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//SynchronizedStatement/Block[1][count(*) = 0]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
 public void bar() {
  synchronized (this) {
   // empty!
  }
 }
}
]]>
      </example>
    </rule>
	
	
    <rule name="UnnecessaryReturn"
    		 since="1.3"
          message="Avoid unnecessary return statements"
          class="net.sourceforge.pmd.rules.basic.UnnecessaryReturn"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryReturn">
      <description>
Avoid unnecessary return statements
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
 public void bar() {
  int x = 42;
  return;
 }
}
 ]]>
      </example>
    </rule>

	
    <rule name="EmptyStaticInitializer"
    		  since="1.5"
           message="Empty static initializer was found"
           class="net.sourceforge.pmd.rules.XPathRule"
           externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyStaticInitializer">
       <description>
An empty static initializer was found.
       </description>
       <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Initializer[@Static='true']/Block[count(*)=0]
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class Foo {
 static {
  // empty
 }
 }
]]>
       </example>
     </rule>
	 
	 
    <rule name="UnconditionalIfStatement"
    		  since="1.5"
       message="Do not use 'if' statements that are always true or always false"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnconditionalIfStatement">
      <description>
Do not use "if" statements that are always true or always false.
      </description>
      <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
 <![CDATA[
//IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}
]]>
      </example>
    </rule>
	
	<!-- 
		pohl: This rule might needs to be revised. 
		I think it is also not validwithin a loop... 
	-->
    <rule name="EmptyStatementNotInLoop"
    		 since="1.5"
          message="An empty statement (semicolon) not part of a loop"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyStatementNotInLoop">
       <description>
An empty statement (aka a semicolon by itself) that is not used
as the sole body of a for loop or while loop is probably a bug.  It
could also be a double semicolon, which is useless and should be
removed.
       </description>
       <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//EmptyStatement
 [not(
       ../../../ForStatement
       or ../../../WhileStatement
       or ../../../BlockStatement/ClassOrInterfaceDeclaration
       or ../../../../../../ForStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement
       or ../../../../../../WhileStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement)
 ]
]]>
                </value>
            </property>
        </properties>
       <example>
<![CDATA[
public class MyClass {
   public void doit() {
      // this is probably not what you meant to do
      ;
      // the extra semicolon here this is not necessary
      System.out.println("look at the extra semicolon");;
   }
}
]]>
       </example>
     </rule>
	 
	 <!--  pohl custom rule not to import from child packages -->
	 <rule name="ImportFromChildPackage"
          message="You must not import from a child package."
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
You must not import from a child package. It usually indicates coupling to a specific implementation rather than referencing the interface of the implementation.
       </description>
       <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
/ImportDeclaration/Name[starts-with(@Image,concat(/PackageDeclaration/Name/@Image, '.'))]
]]></value>
            </property>
        </properties>
       <example>
<![CDATA[
package com.hybris.cool.stuff;

// OK - importing from parent is totally fine
import com.hybris.cool;

// OK - importing from package on same hierachy level is fine
import com.hybris.cool.muuh;

// ERROR - but you must not import from deeper/child packages
import com.hybris.cool.stuff.impl;

public class MyClass {
// ...
}
]]>
       </example>
     </rule>
	 
    <rule name="BooleanInstantiation"
    	 since="1.2"
       message="Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead."
       class="net.sourceforge.pmd.rules.basic.BooleanInstantiation"
       externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BooleanInstantiation">
   <description>
Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.
   </description>
      <priority>2</priority>
   <example>
   <![CDATA[
public class Foo {
 Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE;
 Boolean buz = Boolean.valueOf(false); // just do a Boolean buz = Boolean.FALSE;
}
   ]]>
   </example>
   </rule>
   
    <rule name="UnnecessaryFinalModifier"
    		 since="3.0"
          message="Unnecessary final modifier in final class"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryFinalModifier">
      <description>
When a class has the final modifier, all the methods are automatically final.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Final='true' and @Interface='false']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Final='true']
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public final class Foo {
    // This final modifier is not necessary, since the class is final
    // and thus, all methods are final
    private final void foo() {
    }
}

]]>
      </example>
    </rule>
    <rule name="CollapsibleIfStatements"
    		 since="3.1"
          message="These nested if statements could be combined"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#CollapsibleIfStatements">
      <description>
Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
      </description>
      <priority>2</priority>
      <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//IfStatement[@Else='false']/Statement
 /IfStatement[@Else='false']
 |
//IfStatement[@Else='false']/Statement
 /Block[count(BlockStatement)=1]/BlockStatement
  /Statement/IfStatement[@Else='false']]]>
            </value>
        </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 void bar() {
  if (x) {
   if (y) {
    // do stuff
   }
  }
 }
}
 ]]>
      </example>
    </rule>
	
    <rule name="UselessOverridingMethod"
    since="3.3"
    message="Overriding method merely calls super"
    class="net.sourceforge.pmd.rules.UselessOverridingMethod"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UselessOverridingMethod">
        <description>
The overriding method merely calls the same method defined in a superclass
        </description>
        <priority>2</priority>
        <properties>
            <property name="ignoreAnnotations" description="Ignore annotations" value="false"/>
        </properties>
        <example><![CDATA[
public void foo(String bar) {
    super.foo(bar);      //Why bother overriding?
}
        ]]></example>
        <example><![CDATA[
public String foo() {
    return super.foo();  //Why bother overriding?
}
        ]]></example>
        <example><![CDATA[
@Id
public Long getId() {
    return super.getId();  //OK if 'ignoreAnnotations' is false, which is the default behavior
}
        ]]></example>
    </rule>
	
	
 <rule name="ClassCastExceptionWithToArray"
       since="3.4"
       message="This usage of the Collection.toArray() method will throw a ClassCastException."
       class="net.sourceforge.pmd.rules.XPathRule"
       externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ClassCastExceptionWithToArray">
  <description>
if you need to get an array of a class from your Collection,
you should pass an array of the desidered class
as the parameter of the toArray method. Otherwise you will get a
ClassCastException.
  </description>
  <priority>1</priority>
  <properties>
    <property name="xpath">
    <value>
<![CDATA[
//CastExpression[Type/ReferenceType/ClassOrInterfaceType[@Image !=
"Object"]]//PrimaryExpression
[
 PrimaryPrefix/Name[ends-with(@Image, '.toArray')]
 and
 PrimarySuffix/Arguments[count(*) = 0]
and
count(PrimarySuffix) = 1
]
]]>
    </value>
    </property>
  </properties>
  <example>
<![CDATA[
import java.util.ArrayList;
import java.util.Collection;

public class Test {

    public static void main(String[] args) {
        Collection c=new ArrayList();
        Integer obj=new Integer(1);
        c.add(obj);

        // this would trigger the rule (and throw a ClassCastException
if executed)
        Integer[] a=(Integer [])c.toArray();

        // this wouldn't trigger the rule
        Integer[] b=(Integer [])c.toArray(new Integer[c.size()]);
    }
}
]]>
  </example>
</rule>

<rule  name="AvoidDecimalLiteralsInBigDecimalConstructor"
       since="3.4"
       message="Avoid creating BigDecimal with a decimal (float/double) literal. Use a String literal"
       class="net.sourceforge.pmd.rules.XPathRule"
       externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidDecimalLiteralsInBigDecimalConstructor">
  <description>
     One might assume that "new BigDecimal(.1)" is exactly equal
     to .1, but it is actually equal
     to .1000000000000000055511151231257827021181583404541015625.
     This is so because .1 cannot be represented exactly as a double
     (or, for that matter, as a binary fraction of any finite length).
     Thus, the long value that is being passed in to the constructor
     is not exactly equal to .1, appearances notwithstanding.

     The (String) constructor, on the other hand, is perfectly predictable:
     'new BigDecimal(".1")' is exactly equal to .1, as one
     would expect.  Therefore, it is generally recommended that the (String)
     constructor be used in preference to this one.
  </description>
  <priority>3</priority>
  <properties>
    <property name="xpath">
    <value>
<![CDATA[
//AllocationExpression[ClassOrInterfaceType[@Image="BigDecimal"]
and
./Arguments/ArgumentList
/Expression/PrimaryExpression/PrimaryPrefix/Literal[(not
(ends-with
(@Image,'"'))) and contains(@Image,".")]]
 ]]>
    </value>
    </property>
  </properties>
  <example>
<![CDATA[
import java.math.BigDecimal;
public class Test {

    public static void main(String[] args) {
      // this would trigger the rule
     BigDecimal bd=new BigDecimal(1.123);
      // this wouldn't trigger the rule
     BigDecimal bd=new BigDecimal("1.123");
      // this wouldn't trigger the rule
     BigDecimal bd=new BigDecimal(12);
    }
}
]]>
  </example>
</rule>

    <rule  name="UselessOperationOnImmutable"
           since="3.5"
           message="An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself"
           class="net.sourceforge.pmd.rules.UselessOperationOnImmutable"
           externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UselessOperationOnImmutable">
      <description>
    An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself. The
    result of the operation is a new object. Therefore, ignoring the operation result is an error.
      </description>
      <priority>2</priority>
      <example>
    <![CDATA[
import java.math.*;
class Test {
 void method1() {
  BigDecimal bd=new BigDecimal(10);
  bd.add(new BigDecimal(5)); // this will trigger the rule
 }
 void method2() {
  BigDecimal bd=new BigDecimal(10);
  bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
 }
}
    ]]>
      </example>
    </rule>

    <rule  name="MisplacedNullCheck"
           since="3.5"
           message="The null check here is misplaced; if the variable is null there'll be a NullPointerException"
           class="net.sourceforge.pmd.rules.XPathRule"
           externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#MisplacedNullCheck">
      <description>
    The null check here is misplaced. if the variable is null you'll get a NullPointerException.
    Either the check is useless (the variable will never be "null") or it's incorrect.
      </description>
      <priority>1</priority>
      <properties>
        <property name="xpath">
        <value>
    <![CDATA[
//Expression
    /*[self::ConditionalOrExpression or self::ConditionalAndExpression]
     /descendant::PrimaryExpression/PrimaryPrefix
      /Name[starts-with(@Image,
      concat(ancestor::PrimaryExpression/following-sibling::EqualityExpression
       [./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
     /PrimaryExpression/PrimaryPrefix
      /Name[count(../../PrimarySuffix)=0]/@Image,"."))
    ]
    ]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
public class Foo {
 void bar() {
  if (a.equals(baz) && a != null) {}
 }
}
    ]]>
      </example>
      <example><![CDATA[
public class Foo {
 void bar() {
  if (a.equals(baz) || a == null) {}
 }
}
   ]]></example>
    </rule>

    <rule name="UnusedNullCheckInEquals"
        since="3.5"
        message="Invoke equals() on the object you''ve already ensured is not null"
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnusedNullCheckInEquals">
    <description>
    After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.
    </description>
	<priority>2</priority>
    <properties>
        <property name="xpath">
        <value>
        <![CDATA[
//PrimarySuffix[@Image='equals' and not(../PrimaryPrefix/Literal)]
 /following-sibling::PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix
 /Name[@Image = ./../../../../../../../../../../Expression/ConditionalAndExpression
 /EqualityExpression[@Image="!=" and count(./preceding-sibling::*)=0 and
 ./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
  /PrimaryExpression/PrimaryPrefix/Name/@Image]
        ]]>
        </value>
        </property>
    </properties>
<example>
<![CDATA[
public class Test {

public String method1() { return "ok";}
public String method2() { return null;}

public void method(String a) {
String b;
/*
I don't know it method1() can be "null"
but I know "a" is not null..
I'd better write a.equals(method1())
*/
if (a!=null && method1().equals(a)) { // will
trigger the rule
//whatever
}

if (method1().equals(a) && a != null) { //
won't trigger the rule
//whatever
}

if (a!=null && method1().equals(b)) { // won't
trigger the rule
//whatever
}

if (a!=null && "LITERAL".equals(a)) { // won't
trigger the rule
//whatever
}

if (a!=null && !a.equals("go")) { // won't
trigger the rule
a=method2();
if (method1().equals(a)) {
//whatever
}
}
}
}
]]>
</example>
</rule>


    <rule  name="AvoidThreadGroup"
      since="3.6"
      message="Avoid using ThreadGroup; it is not thread safe"
      class="net.sourceforge.pmd.rules.XPathRule"
      externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidThreadGroup">
      <description>
Avoid using ThreadGroup; although it is intended to be used in a threaded environment
 it contains methods that are not thread safe.
      </description>
      <priority>3</priority>
      <properties>
        <property name="xpath">
        <value>
<![CDATA[
//AllocationExpression/ClassOrInterfaceType[contains(@Image,'ThreadGroup')] |
//PrimarySuffix[contains(@Image, 'getThreadGroup')]
]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
    public class Bar {
     void buz() {
      ThreadGroup tg = new ThreadGroup("My threadgroup") ;
      tg = new ThreadGroup(tg, "my thread group");
      tg = Thread.currentThread().getThreadGroup();
      tg = System.getSecurityManager().getThreadGroup();
     }
    }
    ]]>
      </example>
    </rule>

    <rule name="BrokenNullCheck"
          since="3.8"
          message="Method call on object which may be null"
          class="net.sourceforge.pmd.rules.basic.BrokenNullCheck"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BrokenNullCheck">
        <description>
The null check is broken since it will throw a NullPointerException itself.
It is likely that you used || instead of &amp;&amp; or vice versa.
     </description>
        <priority>2</priority>
        <example>
<![CDATA[
class Foo {
 String bar(String string) {
  // should be &&
  if (string!=null || !string.equals(""))
    return string;
  // should be ||
  if (string==null && string.equals(""))
    return string;
 }
}
        ]]>
        </example>
    </rule>

<rule name="BigIntegerInstantiation"
  since="3.9"
  message="Don't create instances of already existing
BigInteger and BigDecimal (ZERO, ONE, TEN)"
  class="net.sourceforge.pmd.rules.basic.BigIntegerInstantiation"
  externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BigIntegerInstantiation">
  <description>
Don't create instances of already existing BigInteger
(BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
BigDecimal.ONE, BigDecimal.TEN)
  </description>
  <priority>3</priority>
  <example>
<![CDATA[
public class Test {

 public static void main(String[] args) {
   BigInteger bi=new BigInteger(1);
   BigInteger bi2=new BigInteger("0");
   BigInteger bi3=new BigInteger(0.0);
   BigInteger bi4;
   bi4=new BigInteger(0);
 }
}
]]>
  </example>
</rule>

    <rule   name="AvoidUsingOctalValues"
            since="3.9"
            message="Do not start a literal by 0 unless it's an octal value"
            class="net.sourceforge.pmd.rules.basic.AvoidUsingOctalValues"
            externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidUsingOctalValues">
    <description>
    	<![CDATA[
		    Integer literals should not start with zero.
		    Zero means that the rest of literal will be interpreted as an octal value.
    	]]>
    </description>
    <priority>3</priority>
    <example>
		    <![CDATA[
		public class Foo {
		  int i = 012; // set i with 10 not 12
		  int j = 010; // set j with 8 not 10
		  k = i * j; // set k with 80 not 120
		}
		    ]]>
    </example>
    </rule>

    <rule   name="AvoidUsingHardCodedIP"
            since="4.1"
            message="Do not hard code IPv4 or IPv6 addresses, even 127.0.0.1 !"
            class="net.sourceforge.pmd.rules.basic.AvoidUsingHardCodedIP"
            externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidUsingHardCodedIP">
	    <description>
	    	<![CDATA[
				An application with hard coded IP may become impossible to deploy in some case. It never hurts
				to externalize IP adresses.
	    	]]>
	    </description>
	    <priority>3</priority>
	     <properties>
            <property name="pattern" description="Regular Expression" value='^"[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"$'/>
        </properties>
	    <example>
	    <![CDATA[
	public class Foo {
	  String ip = "127.0.0.1"; // This is a really bad idea !
	}
	    ]]>
	    </example>
    </rule>

  <rule
        name="CheckResultSet"
        since="4.1"
        class="net.sourceforge.pmd.rules.XPathRule"
        message="Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet."
        externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#CheckResultSet">
        <description>
            <![CDATA[
	            Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet. Indeed,
	            if the value return is 'false', the developer should deal with it !
            ]]>
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
		        	<![CDATA[
//Type/ReferenceType/ClassOrInterfaceType[
        (@Image = 'ResultSet')
        and
        (../../../descendant::Name[ends-with(@Image,'executeQuery')])
        and
        (
	(not (contains(
                        (./ancestor::Block/descendant::WhileStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.next')
		)  ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.next')
		) ) )
	and (not (contains(
                        (./ancestor::Block/descendant::WhileStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.previous')
		)  ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.previous')
		) ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.last')
		) ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.first')
		) ) )

         )
]
		        	]]>
            	</value>
            </property>
        </properties>
        <example>
            <![CDATA[
            // This is NOT appropriate !
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            rst.next(); // what if it returns a 'false' ?
            String firstName = rst.getString(1);

            // This is appropriate...
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            if (rst.next())
            {
                String firstName = rst.getString(1);
            }
            else
            {
                // here you deal with the error ( at least log it)
            }
            ]]>
        </example>
    </rule>

	<rule name="AvoidMultipleUnaryOperators"
		since="4.2"
		class="net.sourceforge.pmd.rules.basic.AvoidMultipleUnaryOperators"
		message="Using multiple unary operators may be a bug, and/or is confusing."
        externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidMultipleUnaryOperators">
        <description>
            <![CDATA[
					Using multiple unary operators may be a bug, and/or is confusing.
					Check the usage is not a bug, or consider simplifying the expression.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
		        	<![CDATA[
//UnaryExpression[
		./UnaryExpression
		or ./UnaryExpressionNotPlusMinus
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpression
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpressionNotPlusMinus
	]
|
//UnaryExpressionNotPlusMinus[
		./UnaryExpression
		or ./UnaryExpressionNotPlusMinus
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpression
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpressionNotPlusMinus
	]
		        	]]>
            	</value>
            </property>
        </properties>
        <example>
            <![CDATA[
            // These are typo bugs, or at best needlessly complex and confusing:
            int i = - -1;
            int j = + - +1;
            int z = ~~2;
            boolean b = !!true;
            boolean c = !!!true;

            // These are better:
            int i = 1;
            int j = -1;
            int z = 2;
            boolean b = true;
            boolean c = false;

            // And these just make your brain hurt:
            int i = ~-2;
            int j = -~7;
            ]]>
        </example>
    </rule>

    <rule name="EmptyInitializer"
	  since="5.0"
          message="Empty initializer was found"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyInitializer">
       <description>
An empty initializer was found.
       </description>
       <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Initializer/Block[count(*)=0]
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class Foo {

   static {} // Why ?

   {} // Again, why ?

}
    ]]>
    </example>
  </rule>
  
  
  <!-- rule copied and adaped from PMD (4.2.5) 'braces.xml' -->
   <rule name="IfStmtsMustUseBraces"
   		since="1.0"
         message="Avoid using if statements without curly braces"
         class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/braces.html#IfStmtsMustUseBraces">
     <description>
Avoid using if statements without using curly braces.
     </description>
     <priority>2</priority>
       <properties>
           <property name="xpath">
               <value>
                   <![CDATA[
//IfStatement[count(*) < 3][not(Statement/Block)]
                   ]]>
               </value>
           </property>
       </properties>
     <example>
 <![CDATA[
 public class Foo {
   public void bar() {
     int x = 0;
     if (foo) x++;
   }
 }
 ]]>
     </example>
     </rule>

    <rule name="WhileLoopsMustUseBraces"
    		 since="0.7"
          message="Avoid using 'while' statements without curly braces"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/braces.html#WhileLoopsMustUseBraces">
      <description>
Avoid using 'while' statements without using curly braces.
      </description>
      <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//WhileStatement[not(Statement/Block)]
]]>
                </value>
            </property>
        </properties>
      <example>
<![CDATA[
public void doSomething() {
  while (true)
      x++;
}
]]>
      </example>
    </rule>

      <rule name="IfElseStmtsMustUseBraces"
      	  since="0.2"
           message="Avoid using 'if...else' statements without curly braces"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/braces.html#IfElseStmtsMustUseBraces">
       <description>
Avoid using if..else statements without using curly braces.
       </description>
       <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Statement
 [parent::IfStatement[@Else='true']]
 [not(child::Block)]
 [not(child::IfStatement)]
 ]]>
                 </value>
             </property>
         </properties>
       <example>
<![CDATA[
 public void doSomething() {
   // this is OK
   if (foo) x++;
   // but this is not
   if (foo)
       x=x+1;
   else
       x=x-1;
 }
]]>
       </example>
     </rule>

     <rule name="ForLoopsMustUseBraces"
     		  since="0.7"
           message="Avoid using 'for' statements without curly braces"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/braces.html#ForLoopsMustUseBraces">
       <description>
Avoid using 'for' statements without using curly braces.
       </description>
       <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
 <![CDATA[
//ForStatement[not(Statement/Block)]
 ]]>
                 </value>
             </property>
         </properties>
       <example>
<![CDATA[
public void foo() {
 for (int i=0; i<42;i++)
   foo();
}
]]>
       </example>
     </rule>

	 <!-- Rule adapted from PMD (4.2.5) 'clone.xml' -->
	 
	 
    <rule name="ProperCloneImplementation"
    		since="1.4"
         message="Object clone() should be implemented with super.clone()"
         class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/clone.html#ProperCloneImplementation">
     <description>
Object clone() should be implemented with super.clone().
     </description>
     <priority>2</priority>
     <properties>
         <property name="xpath">
             <value>
                 <![CDATA[
//MethodDeclarator
[@Image = 'clone']
[count(FormalParameters/*) = 0]
[count(../Block//*[
    (self::AllocationExpression) and
    (./ClassOrInterfaceType/@Image = ancestor::
ClassOrInterfaceDeclaration[1]/@Image)
  ])> 0
]
                ]]>
             </value>
         </property>
     </properties>
     <example>
 <![CDATA[
class Foo{
    public Object clone(){
        return new Foo(); // This is bad
    }
}
]]>
     </example>
     </rule>

    <rule name="CloneThrowsCloneNotSupportedException"
    		since="1.9"
         message="clone() method should throw CloneNotSupportedException"
         class="net.sourceforge.pmd.rules.XPathRule"
         externalInfoUrl="http://pmd.sourceforge.net/rules/clone.html#CloneThrowsCloneNotSupportedException">
         <description>
The method clone() should throw a CloneNotSupportedException.
         </description>
         <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
                     <![CDATA[
//MethodDeclaration
[
MethodDeclarator/@Image = 'clone'
and count(MethodDeclarator/FormalParameters/*) = 0
and count(NameList/Name[contains
(@Image,'CloneNotSupportedException')]) = 0
]
[
../../../../ClassOrInterfaceDeclaration[@Final = 'false']
]
                     ]]>
                 </value>
             </property>
         </properties>
         <example>
             <![CDATA[
 public class MyClass implements Cloneable{
     public Object clone() { // will cause an error
          MyClass clone = (MyClass)super.clone();
          return clone;
     }
 }
    ]]>
         </example>
     </rule>

    <rule name="CloneMethodMustImplementCloneable"
    	  since="1.9"
        message="clone() method should be implemented only if implementing Cloneable interface"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/clone.html#CloneMethodMustImplementCloneable">
        <description>
The method clone() should only be implemented if the class implements the Cloneable interface with the exception of a final method that only throws CloneNotSupportedException.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
[not(./ImplementsList/ClassOrInterfaceType
[@Image='Cloneable'])]
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
[MethodDeclaration
[MethodDeclarator[@Image
= 'clone' and count(FormalParameters/*) = 0]]
[not((../MethodDeclaration[@Final = 'true'] or ancestor::ClassOrInterfaceDeclaration[1][@Final = 'true'])
and Block[count(BlockStatement)=1]
/BlockStatement/Statement/ThrowStatement/Expression
/PrimaryExpression/PrimaryPrefix/AllocationExpression
/ClassOrInterfaceType[@Image = 'CloneNotSupportedException'])]]

                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class MyClass {
 public Object clone() throws CloneNotSupportedException {
  return foo;
 }
}
   ]]>
        </example>
    </rule>
	
	<!-- rules adapted from PMD (4.2.5) 'codesize.xml' -->
	
<rule name="NPathComplexity"
      since="3.9"
      message="The method {0}() has an NPath complexity of {1}. NPath complexity should not exceed 150."
      class="net.sourceforge.pmd.rules.design.NpathComplexity"
      externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NPathComplexity">
   <description>
   The NPath complexity of a method is the number of acyclic execution paths through that method.
   A threshold of 150 is generally considered the point where measures should be taken to reduce complexity.
   </description>
     <priority>3</priority>
   <properties>
    <property name="minimum" description="The npath reporting threshold" value="150"/>
   </properties>
    <example>
 <![CDATA[
 public class Foo {
  void bar() {
   // lots of complicated code
  }
 }
 ]]>
    </example>
</rule>

<rule name="NPathComplexity2"
      since="3.9"
      message="The method {0}() has an NPath complexity of {1}. A Maximum of 200 is allowed."
      class="net.sourceforge.pmd.rules.design.NpathComplexity"
      externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NPathComplexity">
   <description>
   The NPath complexity of a method is the number of acyclic execution paths through that method.
   A threshold of 200 is generally considered the point where measures must be taken to reduce complexity.
   </description>
     <priority>2</priority>
   <properties>
    <property name="minimum" description="The npath reporting threshold" value="200"/>
   </properties>
    <example>
 <![CDATA[
 public class Foo {
  void bar() {
   // lots of complicated code
  }
 }
 ]]>
    </example>
</rule>

 <rule name="ExcessiveMethodLength"
 		 since="0.6"
       message="Avoid really long methods."
       class="net.sourceforge.pmd.rules.design.LongMethodRule"
       externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessiveMethodLength">
   <description>
Violations of this rule usually indicate that the method is doing
too much.  Try to reduce the method size by creating helper methods and removing any copy/pasted code.
   </description>
     <priority>3</priority>
   <properties>
    <property name="minimum" description="The method size reporting threshold" value="100"/>
   </properties>
   <example>
<![CDATA[
public class Foo {
 public void doSomething() {
  System.out.println("Hello world!");
  System.out.println("Hello world!");
  // 38 copies omitted for brevity.
 }
}
]]>
   </example>

 </rule>
 
  <rule name="SpaghettiCodeWithComments"
 		 since="0.6"
       message="Avoid really long methods."
       class="net.sourceforge.pmd.rules.design.LongMethodRule"
       externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessiveMethodLength">
   <description>
Violations of this rule usually indicate that the method is doing
too much.  Reduce the method size by splitting this functionality over several methods.
   </description>
     <priority>2</priority>
   <properties>
    <property name="minimum" description="The method size reporting threshold" value="200"/>
   </properties>
   <example>
<![CDATA[
public class Foo {
 public void doSomething() {
  System.out.println("Hello world!");
  System.out.println("Hello world!");
  // 98 copies omitted for brevity.
 }
}
]]>
   </example>
 </rule>
 
 
<rule name="NcssMethodCount" message="The method {0}() has an NCSS line count of {1}"
   since="3.9"
   class="net.sourceforge.pmd.rules.codesize.NcssMethodCount"
   externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NcssMethodCount">
    <description>
This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines
of code for a given method. NCSS ignores comments, and counts actual statements. Using this algorithm,
lines of code that are split are counted as one.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" description="The method NCSS count reporting threshold" value="40"/>
    </properties>
   <example>
<![CDATA[
public class Foo extends Bar {
 public int methd() {
     super.methd();





 //this method only has 1 NCSS lines
      return 1;
 }
}
]]>
   </example>
   </rule>
   
   <rule name="SpaghettiCode" message="Spaghetti code: The method {0}() has an NCSS line count of {1}."
   since="3.9"
   class="net.sourceforge.pmd.rules.codesize.NcssMethodCount"
   externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NcssMethodCount">
    <description>
This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines
of code for a given method. NCSS ignores comments, and counts actual statements. Using this algorithm,
lines of code that are split are counted as one.
    </description>
    <priority>2</priority>
    <properties>
        <property name="minimum" description="The method NCSS count reporting threshold" value="100"/>
    </properties>
   <example>
<![CDATA[
public class Foo extends Bar {
 public int methd() {
     super.methd();





 //this method only has 1 NCSS lines
      return 1;
 }
}
]]>
   </example>
   </rule>


<rule name="NcssConstructorCount" message="The constructor with {0} parameters has an NCSS line count of {1}"
   since="3.9"
   class="net.sourceforge.pmd.rules.codesize.NcssConstructorCount"
   externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NcssConstructorCount">
    <description>
This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines
of code for a given constructor. NCSS ignores comments, and counts actual statements. Using this algorithm,
lines of code that are split are counted as one.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" description="The constructor NCSS count reporting threshold" value="40"/>
    </properties>
   <example>
<![CDATA[
public class Foo extends Bar {
 public Foo() {
     super();





 //this constructor only has 1 NCSS lines
      super.foo();
 }
}
]]>
   </example>
</rule>


 <rule name="ExcessiveParameterList"
 		 since="0.9"
       message="Avoid really long parameter lists."
       class="net.sourceforge.pmd.rules.design.LongParameterListRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessiveParameterList">
   <description>
Long parameter lists can indicate that a new object should be created to
 wrap the numerous parameters.  Basically, try to group the parameters together.
   </description>
     <priority>3</priority>
   <properties>
    <property name="minimum" description="The parameter count reporting threshold" value="7"/>
   </properties>
   <example>
<![CDATA[
public class Foo {
 public void addData(
  int p0, int p1, int p2, int p3, int p4, int p5,
  int p5, int p6, int p7, int p8, int p9, int p10) {
  }
 }
}
]]>
   </example>

 </rule>
 
  <rule name="ExcessiveParameterList2"
 		 since="0.9"
       message="Avoid really long parameter lists."
       class="net.sourceforge.pmd.rules.design.LongParameterListRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessiveParameterList">
   <description>
Long parameter lists can indicate that a new object should be created to
 wrap the numerous parameters.  Basically, try to group the parameters together.
   </description>
     <priority>3</priority>
   <properties>
    <property name="minimum" description="The parameter count reporting threshold" value="10"/>
   </properties>
   <example>
<![CDATA[
public class Foo {
 public void addData(
  int p0, int p1, int p2, int p3, int p4, int p5,
  int p5, int p6, int p7, int p8, int p9, int p10) {
  }
 }
}
]]>
   </example>

 </rule>


 <rule name="ExcessiveClassLength"
 		 since="0.6"
       message="Avoid really long classes."
       class="net.sourceforge.pmd.rules.design.LongClassRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessiveClassLength">
   <description>
Long Class files are indications that the class may be trying to
do too much.  Try to break it down, and reduce the size to something
manageable.
   </description>
     <priority>3</priority>
       <properties>
        <property name="minimum" description="The class size reporting threshold"  value="1500"/>
       </properties>
   <example>
<![CDATA[
public class Foo {
  public void bar() {
    // 1000 lines of code
  }
}
]]>
   </example>
 </rule>

<rule name="NcssTypeCount" message="The type has an NCSS line count of {0}"
   since="3.9"
   class="net.sourceforge.pmd.rules.codesize.NcssTypeCount"
   externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#NcssTypeCount">
    <description>
This rule uses the NCSS (Non Commenting Source Statements) algorithm to determine the number of lines
of code for a given type. NCSS ignores comments, and counts actual statements. Using this algorithm,
lines of code that are split are counted as one.
    </description>
    <priority>3</priority>
    <properties>
        <property name="minimum" description="The type NCSS count reporting threshold" value="1000"/>
    </properties>
   <example>
<![CDATA[
public class Foo extends Bar {
 public Foo() {
 //this class only has 6 NCSS lines
     super();





      super.foo();
 }
}
]]>
   </example></rule>

    <rule 	name="CyclomaticComplexity"
    			since="1.03"
      		message = "The {0} ''{1}'' has a Cyclomatic Complexity of {2}."
	      	class="net.sourceforge.pmd.rules.CyclomaticComplexity"
	      	externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#CyclomaticComplexity">
   <description>
   		<![CDATA[
Complexity is determined by the number of decision points in a method plus one for the
method entry.  The decision points are 'if', 'while', 'for', and 'case labels'.  Generally,
1-4 is low complexity, 5-7 indicates moderate complexity, 8-10 is high complexity,
 and 11+ is very high complexity.
		]]>
   </description>
   <priority>3</priority>
   <properties>
      <property name="reportLevel" description="The Cyclomatic Complexity reporting threshold"  value="10"/>
      <property name="showClassesComplexity"
      			description="Indicate if class average violation should be added to the report"
      			value="true"/>
      <property name="showMethodsComplexity"
      			description="Indicate if class average violation should be added to the report"
      			value="true"/>

   </properties>
   <example>
<![CDATA[
// Cyclomatic Complexity = 12
public class Foo {
1   public void example()  {
2       if (a == b)  {
3           if (a1 == b1) {
                fiddle();
4           } else if a2 == b2) {
                fiddle();
            }  else {
                fiddle();
            }
5       } else if (c == d) {
6           while (c == d) {
                fiddle();
            }
7        } else if (e == f) {
8           for (int n = 0; n < h; n++) {
                fiddle();
            }
        } else{
            switch (z) {
9               case 1:
                    fiddle();
                    break;
10              case 2:
                    fiddle();
                    break;
11              case 3:
                    fiddle();
                    break;
12              default:
                    fiddle();
                    break;
            }
        }
    }
}
]]>
   </example>
</rule>

	<!-- 
		pohl: using TooManyPublicMethods rule instead (see below)
		
    <rule name="ExcessivePublicCount"
    since="1.04"
    message="This class has a bunch of public methods and attributes"
    class="net.sourceforge.pmd.rules.ExcessivePublicCount"
          externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#ExcessivePublicCount">
    <description>
A large number of public methods and attributes declared in a class can indicate the
 class may need to be broken up as increased effort will be required to thoroughly test it.
    </description>
    <priority>3</priority>
    <properties>
    <property name="minimum"  description="The public item reporting threshold" value="10"/>
    </properties>
    <example>
    <![CDATA[
public class Foo {
 public String value;
 public Bar something;
 public Variable var;
 // [... more more public attributes ...]
 public void doWork() {}
 public void doMoreWork() {}
 public void doWorkAgain() {}
 // [... more more public methods ...]
}
    ]]>
    </example>
    </rule>
	-->
	
    <rule name="TooManyFields"
    		 since="3.0"
          message="Too many fields"
          class="net.sourceforge.pmd.rules.design.TooManyFields"
          externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#TooManyFields">
      <description>
Classes that have too many fields could be redesigned to have fewer fields, possibly
 through some nested object grouping of some of the information.  For example, a class with
 city/state/zip fields could instead have one Address field.
      </description>
        <priority>3</priority>
      <properties>
       <property name="maxfields"  description="The field count reporting threshold " value="15"/>
      </properties>
      <example>
   <![CDATA[
public class Person {
   String one;
   int two;
   int three;
   [... many more public fields ...]
}
   ]]>
      </example>
    </rule>


    <rule
        name="TooManyMethods"
        since="4.2"
        class="net.sourceforge.pmd.rules.XPathRule"
        message="This class has too many methods, consider refactoring it."
        externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#TooManyMethods">
        <description>
            <![CDATA[
A class with too many methods is probably a good suspect for refactoring, in order to reduce its complexity and find a way to
have more fine grained objects.
            ]]>
        </description>
        <priority>4</priority>
        <properties>
                <property name="maxmethods"  description="The method count reporting threshold " value="30"/>
                <property name="xpath">
                <value>
                    <!--  FIXME: Refine XPath to discard 'get' and 'set' methods with Block no more than 3 lines,
                                something like this:
                                    not (
                                    (
                                    starts-with(@Image,'get')
                                        or
                                    starts-with(@Image,'set')
                                    )
                                    and ( (
                                        (../Block/attribute::endLine)
                                         -
                                        (../Block/attribute::beginLine) ) <= 3 )
                                    )
                                This will avoid discarding 'real' method...
                     -->
                    <![CDATA[
					//ClassOrInterfaceDeclaration/ClassOrInterfaceBody [
						count(descendant::MethodDeclarator[
							not
							(
								starts-with(@Image,'get')
								or
								starts-with(@Image,'set')
								or
								starts-with(@Image,'is')
								or
								starts-with(@Image,'should')
								or
								starts-with(@Image,'test')
							)
						]) > $maxmethods
					]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

	<rule
        name="TooManyPublicMethods"
        since="4.2"
        class="net.sourceforge.pmd.rules.XPathRule"
        message="This class has too many public methods, consider refactoring it."
        externalInfoUrl="http://pmd.sourceforge.net/rules/codesize.html#TooManyMethods">
        <description>
            <![CDATA[
A class with too many methods is probably a good suspect for refactoring, in order to reduce its complexity and find a way to
have more fine grained objects.
            ]]>
        </description>
        <priority>4</priority>
        <properties>
                <property name="maxmethods"  description="The method count reporting threshold " value="10"/>
                <property name="xpath">
                <value>
                    <![CDATA[
					//ClassOrInterfaceDeclaration/ClassOrInterfaceBody [
						count(descendant::MethodDeclarator[
							not
							(
								starts-with(@Image,'get')
								or
								starts-with(@Image,'set')
								or
								starts-with(@Image,'is')
								or
								starts-with(@Image,'should')
								or
								starts-with(@Image,'test')
							)
							and ( ../@Public = 'true' )
						]) > $maxmethods
					]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>
	
	<!-- adapted rules from the PMD 4.2.5 'controversial.xml' ruleset -->
	
    <rule name="UnnecessaryConstructor"
    		 since="1.0"
          message="Avoid unnecessary constructors - the compiler will generate these for you"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#UnnecessaryConstructor">
      <description>
This rule detects when a constructor is not necessary; i.e., when there's only one constructor,
it's public, has an empty body, and takes no arguments.
      </description>
      <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceBody[count(ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)=1]
/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration
[@Public='true']
[not(FormalParameters/*)]
[not(BlockStatement)]
[not(NameList)]
[count(ExplicitConstructorInvocation/Arguments/ArgumentList/Expression)=0]
                    ]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
public class Foo {
 public Foo() {}
}
  ]]>
      </example>
    </rule>
	
	<!-- pohl: 
		much too common to restrict. 
	
    <rule name="NullAssignment"
    		 since="1.02"
          message="Assigning an Object to null is a code smell.  Consider refactoring."
          class="net.sourceforge.pmd.rules.design.NullAssignmentRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#NullAssignment">
      <description>
 Assigning a "null" to a variable (outside of its declaration) is usually
 bad form.  Some times, the assignment is an indication that the programmer doesn't
 completely understand what is going on in the code.  NOTE: This sort of assignment
 may in rare cases be useful to encourage garbage collection.  If that's what you're using
 it for, by all means, disregard this rule :-)
      </description>
        <priority>4</priority>
      <example>
 <![CDATA[
 public class Foo {
   public void bar() {
     Object x = null; // This is OK.
     x = new Object();
     // Big, complex piece of code here.
     x = null; // This is BAD.
     // Big, complex piece of code here.
   }
 }

 ]]>
      </example>
    </rule>
	-->
	
	<rule name="UnusedModifier"
    		since="1.02"
         message="Avoid modifiers which are implied by the context"
         class="net.sourceforge.pmd.rules.UnusedModifier"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#UnusedModifier">
     <description>
 Fields in interfaces are automatically public static final, and
 methods are public abstract.
 Classes or interfaces nested in an interface are automatically public
 and static (all nested interfaces are automatically static).
 For historical reasons, modifiers which are implied by the context
 are accepted by the compiler, but are superfluous.
     </description>
        <priority>3</priority>
     <example>
 <![CDATA[
public interface Foo {
 public abstract void bar(); // both abstract and public are ignored by the compiler
 public static final int X = 0; // public, static, and final all ignored
 public static class Bar {} // public, static ignored
 public static interface Baz {} // ditto
}
public class Bar {
 public static interface Baz {} // static ignored
}
 ]]>
     </example>
     </rule>
	 
	<rule name="DontImportSun"
    	 since="1.5"
       message="Avoid importing anything from the 'sun.*' packages"
       class="net.sourceforge.pmd.rules.imports.DontImportSun"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#DontImportSun">
       <description>
Avoid importing anything from the 'sun.*' packages.  These packages are not portable and are likely to change.
       </description>
       <priority>2</priority>
       <example>
<![CDATA[
import sun.misc.foo;
public class Foo {}
]]>
       </example>
    </rule>
	
	<rule name="SuspiciousOctalEscape"
    	 since="1.5"
       message="Suspicious decimal characters following octal escape in string literal"
          class="net.sourceforge.pmd.rules.SuspiciousOctalEscape"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#SuspiciousOctalEscape">
      <description>
A suspicious octal escape sequence was found inside a String literal.
The Java language specification (section 3.10.6) says an octal
escape sequence inside a literal String shall consist of a backslash
followed by:

   OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

Any octal escape sequence followed by non-octal digits can be confusing,
e.g. "\038" is interpreted as the octal escape sequence "\03" followed by
the literal character "8".
      </description>
      <priority>3</priority>
      <example>
<![CDATA[
public class Foo {
 public void foo() {
  // interpreted as octal 12, followed by character '8'
  System.out.println("suspicious: \128");
 }
}
]]>
      </example>
    </rule>
	
	
    <rule name="UnnecessaryParentheses"
    		 since="3.1"
          message="This statement may have some unnecessary parentheses"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#UnnecessaryParentheses">
      <description>
Sometimes expressions are wrapped in unnecessary parentheses,
making them look like a function call.
      </description>
      <priority>4</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
          //Expression
           /PrimaryExpression
            /PrimaryPrefix
             /Expression[count(*)=1]
              /PrimaryExpression
              /PrimaryPrefix]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[public class Foo {
      boolean bar() {
          return (true);
      }
  }]]>
      </example>
    </rule>
	
	<!--
		pohl - sometime the package private scope makes definitely sense.
		
	rule name="DefaultPackage"
        since="3.4"
        message="Use explicit scoping instead of the default package private level"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#DefaultPackage">
        <description>
Use explicit scoping instead of the default package private level.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[@Interface='false']
/ClassOrInterfaceBody
/ClassOrInterfaceBodyDeclaration
[
FieldDeclaration[@PackagePrivate='true']
or MethodDeclaration[@PackagePrivate='true']
]
                ]]></value>
            </property>
        </properties>
    </rule-->
	
	<!-- pohl: I see no sense in restricting the unary ! operator on booleans...
	<rule name="BooleanInversion"
          since="3.5"
          message="Use bitwise inversion to invert boolean values"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#BooleanInversion">
      <description>
Use bitwise inversion to invert boolean values - it's the fastest way to do this.
See http://www.javaspecialists.co.za/archive/newsletter.do?issue=042&amp;locale=en_US for specific details
      </description>
      <priority>4</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//AssignmentOperator[@Image="="]/../Expression/UnaryExpressionNotPlusMinus[@Image="!"]
]]>
             </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 public void main(bar) {
  boolean b = true;
  b = !b; // slow
  b ^= true; // fast
 }
}
]]>
      </example>
    </rule>
	-->
	
	<!-- 
		pohl: this rule raises too many false negatives, so I disabled it
		
	    <rule name="DataflowAnomalyAnalysis"
    		  since="3.9"
              message="Found ''{0}''-anomaly for variable ''{1}'' (lines ''{2}''-''{3}'')."
              class="net.sourceforge.pmd.dfa.DaaRule"
              dfa="true"
              externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#DataflowAnomalyAnalysis">
          <description>The dataflow analysis tracks local definitions, undefinitions and references to variables on different paths on the data flow.
From those informations there can be found various problems.

1. UR - Anomaly: There is a reference to a variable that was not defined before. This is a bug and leads to an error.
2. DU - Anomaly: A recently defined variable is undefined. These anomalies may appear in normal source text.
3. DD - Anomaly: A recently defined variable is redefined. This is ominous but don't have to be a bug.
          </description>
          <priority>3</priority>
          <properties>
            <property name="maxviolations" value="100" description="The maximum number of violations per class."/>
            <property name="maxpaths" value="1000" description="The maximum number of checked paths per method. A lower value will increase the performance of the rule but may decrease the number of found anomalies."/>
          </properties>
          <example>
<![CDATA[
public class Foo {
    public void foo() {
	 int buz = 5;
	 buz = 6; // redefinition of buz -> dd-anomaly
	 foo(buz);
	 buz = 2;
    } // buz is undefined when leaving scope -> du-anomaly
}
]]>
          </example>
        </rule>
	-->
	
	<rule
		name="AvoidAccessibilityAlteration"
		  since="4.1"
        message="You should modify visibility of class or methods using getDeclaredConstructors(), getDeclaredConstructor(Class[]), setAccessible() or PrivilegedAction."
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#AvoidAccessibilityAlteration">
        <description>
            <![CDATA[
            Methods such as getDeclaredConstructors(), getDeclaredConstructor(Class[]) and setAccessible(),
            as the interface PrivilegedAction, allow to alter, at runtime, the visilibilty of variable, classes, or
            methods, even if they are private. Obviously, no one should do so, as such behavior is against everything
            encapsulation principal stands for.
            ]]>
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                   <![CDATA[
                        //PrimaryExpression[
                        (
                        (PrimarySuffix[
                                ends-with(@Image,'getDeclaredConstructors')
                                        or
                                ends-with(@Image,'getDeclaredConstructor')
                                        or
                                ends-with(@Image,'setAccessible')
                                ])
                        or
                        (PrimaryPrefix/Name[
                                ends-with(@Image,'getDeclaredConstructor')
                                or
                                ends-with(@Image,'getDeclaredConstructors')
                                or
                                starts-with(@Image,'AccessibleObject.setAccessible')
                                ])
                        )
                        and
                        (//ImportDeclaration/Name[
                                contains(@Image,'java.security.PrivilegedAction')])
                ]
                ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[

			import java.lang.reflect.AccessibleObject;
			import java.lang.reflect.Method;
			import java.security.PrivilegedAction;

			public class Violation {
				public void invalidCallsInMethod() throws SecurityException, NoSuchMethodException {
					// Possible call to forbidden getDeclaredConstructors
					Class[] arrayOfClass = new Class[1];
					this.getClass().getDeclaredConstructors();
					this.getClass().getDeclaredConstructor(arrayOfClass);
					Class clazz = this.getClass();
					clazz.getDeclaredConstructor(arrayOfClass);
					clazz.getDeclaredConstructors();

					// Possible call to forbidden setAccessible
					clazz.getMethod("", arrayOfClass).setAccessible(false);
					AccessibleObject.setAccessible(null, false);
					Method.setAccessible(null, false);
					Method[] methodsArray = clazz.getMethods();
					int nbMethod;
					for ( nbMethod = 0; nbMethod < methodsArray.length; nbMethod++ ) {
						methodsArray[nbMethod].setAccessible(false);
					}

					// Possible call to forbidden PrivilegedAction
					PrivilegedAction priv = (PrivilegedAction) new Object(); priv.run();
				}
			}
					]]>
			</example>
		</rule>
		
	<rule	name="DoNotCallGarbageCollectionExplicitly"
			    since="4.2"
	        	message="Do not explicitly trigger a garbage collection."
	        	class="net.sourceforge.pmd.rules.XPathRule"
	        	externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#DoNotCallGarbageCollectionExplicitly">
        <description>
	        <![CDATA[
		        Calls to System.gc(), Runtime.getRuntime().gc(), and System.runFinalization() are not advised. Code should have the
		        same behavior whether the garbage collection is disabled using the option -Xdisableexplicitgc or not.
		        Moreover, "modern" jvms do a very good job handling garbage collections. If memory usage issues unrelated to memory
			leaks develop within an application, it should be dealt with JVM options rather than within the code itself.
			]]>
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//Name[
(starts-with(@Image, 'System.') and
(starts-with(@Image, 'System.gc') or
starts-with(@Image, 'System.runFinalization'))) or
(
starts-with(@Image,'Runtime.getRuntime') and
../../PrimarySuffix[ends-with(@Image,'gc')]
)
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            public class GCCall
            {
     	public GCCall()
                	{
                        // Explicit gc call !
                        System.gc();
                	}
	public void doSomething()
	 {
		// Explicit gc call !
		Runtime.getRuntime().gc();
	}

public explicitGCcall() { // Explicit gc call ! System.gc(); }

public void doSomething() { // Explicit gc call ! Runtime.getRuntime().gc(); } }


			]]>
		</example>
	</rule>
	
	<!-- rules adapted from the PMD 4.2.5 'coupling.xml' ruleset -->
	
    <rule name="CouplingBetweenObjects"
    		  since="1.04"
        message="High amount of different objects as members denotes a high coupling"
        class="net.sourceforge.pmd.rules.CouplingBetweenObjects"
          externalInfoUrl="http://pmd.sourceforge.net/rules/coupling.html#CouplingBetweenObjects">
    <description>
This rule counts unique attributes, local variables and return types within an object. A number
 higher than specified threshold can indicate a high degree of coupling.
    </description>
    <priority>3</priority>
    <properties>
      <property name="threshold" description="The unique type reporting threshold" value="20"/>
    </properties>
    <example>
<![CDATA[
import com.Blah;
import org.Bar;
import org.Bardo;
public class Foo {
 private Blah var1;
 private Bar var2;
 //followed by many imports of unique objects
 void ObjectC doWork() {
  Bardo var55;
  ObjectA var44;
  ObjectZ var93;
  return something;
 }
}
]]>
    </example>
  </rule>

  <rule name="ExcessiveImports"
    		  since="1.04"
     message="A high number of imports can indicate a high degree of coupling within an object."
     class="net.sourceforge.pmd.rules.ExcessiveImports"
          externalInfoUrl="http://pmd.sourceforge.net/rules/coupling.html#ExcessiveImports">
     <description>
A high number of imports can indicate a high degree of coupling within
an object. Rule counts the number of unique imports and reports a violation
if the count is above the user defined threshold.
  </description>
  <priority>3</priority>
  <properties>
      <property name="minimum" description="The import count reporting threshold" value="35"/>
  </properties>
  <example>
      <![CDATA[
import blah.blah.Baz;
import blah.blah.Bif;
// 18 others from the same package elided
public class Foo {
 public void doWork() {}
}
      ]]>
  </example>
   </rule>

    <rule name="LooseCoupling"
    		 since="0.7"
          message="Avoid using implementation types like ''{0}''; use the interface instead"
          class="net.sourceforge.pmd.rules.design.LooseCoupling"
          externalInfoUrl="http://pmd.sourceforge.net/rules/coupling.html#LooseCoupling">
      <description>
Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead
      </description>
        <priority>2</priority>
      <example>
<![CDATA[
import java.util.*;
public class Bar {
 // Use List instead
 private ArrayList list = new ArrayList();
 // Use Set instead
 public HashSet getFoo() {
  return new HashSet();
 }
}
  ]]>
      </example>
    </rule>
	
	
	<!-- rules adapted from PMD (4.2.5) 'design.xml' ruleset -->
	
	
  <rule name="UseSingleton"
  		  since="0.3"
        message="All methods are static.  Consider using Singleton instead.  Alternatively, you could add a private constructor or make the class abstract to silence this warning."
        class="net.sourceforge.pmd.rules.design.UseSingleton"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseSingleton">
    <description>
    	<![CDATA[
If you have a class that has nothing but static methods, consider making it a Singleton.
Note that this doesn't apply to abstract classes, since their subclasses may
well include non-static methods.  Also, if you want this class to be a Singleton,
remember to add a private constructor to prevent instantiation.
		]]>
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class MaybeASingleton {
 public static void foo() {}
 public static void bar() {}
}
]]>
    </example>
  </rule>


  <rule name="SimplifyBooleanReturns"
  		  since="0.9"
        message="Avoid unnecessary if..then..else statements when returning a boolean"
        class="net.sourceforge.pmd.rules.SimplifyBooleanReturns"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyBooleanReturns">
    <description>
Avoid unnecessary if..then..else statements when returning a boolean.
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}
]]>
    </example>
  </rule>

    <rule name="SimplifyBooleanExpressions"
    		 since="1.05"
          message="Avoid unnecessary comparisons in boolean expressions"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyBooleanExpressions">
      <description>
Avoid unnecessary comparisons in boolean expressions - this complicates simple code.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//EqualityExpression/PrimaryExpression
 /PrimaryPrefix/Literal/BooleanLiteral
]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  ]]>
      </example>
    </rule>

  <rule name="SwitchStmtsShouldHaveDefault"
  		  since="1.0"
        message="Switch statements should have a default label"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SwitchStmtsShouldHaveDefault">
    <description>
Switch statements should have a default label.
    </description>
    <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//SwitchStatement[not(SwitchLabel[@Default='true'])]
                  ]]>
              </value>
          </property>
      </properties>
    <example>
<![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}
]]>
    </example>
    </rule>

  <rule name="AvoidDeeplyNestedIfStmts"
  		  since="1.0"
        message="Deeply nested if..then statements are hard to read"
        class="net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidDeeplyNestedIfStmts">
    <description>
Deeply nested if..then statements are hard to read.
    </description>
      <priority>3</priority>
   <properties>
    <property name="problemDepth" description="The if statement depth reporting threshold" value="3"/>
   </properties>
    <example>
<![CDATA[
public class Foo {
 public void bar(int x, int y, int z) {
  if (x>y) {
   if (y>z) {
    if (z==x) {
     // whew, too deep
    }
   }
  }
 }
}
]]>
    </example>
    </rule>

<!--
    <rule name="AvoidReassigningParameters"
    	  since="1.0"
        message="Avoid reassigning parameters such as ''{0}''"
        class="net.sourceforge.pmd.rules.AvoidReassigningParameters"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidReassigningParameters">
    <description>
Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.
    </description>
        <priority>2</priority>
    <example>
<![CDATA[
public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}
]]>
    </example>
  </rule>
-->

    <rule name="SwitchDensity"
    		 since="1.02"
          message="A high ratio of statements to labels in a switch statement.  Consider refactoring."
          class="net.sourceforge.pmd.rules.design.SwitchDensityRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SwitchDensity">
      <description>
 A high ratio of statements to labels in a switch statement implies that the switch
 statement is doing too much work.  Consider moving the statements into new
 methods, or creating subclasses based on the switch variable.
      </description>
        <priority>3</priority>
        <properties>
         <property name="minimum" description="The switch statement ratio reporting threshold" value="10"/>
        </properties>
      <example>
 <![CDATA[
public class Foo {
 public void bar(int x) {
   switch (x) {
     case 1: {
       // lots of statements
       break;
     } case 2: {
       // lots of statements
       break;
     }
   }
 }
}
 ]]>
      </example>
    </rule>

    <rule name="ConstructorCallsOverridableMethod"
    		 since="1.04"
          message="Overridable {0} called during object construction"
          class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ConstructorCallsOverridableMethod">
      <description>
Calling overridable methods during construction poses a risk of invoking methods on an
incompletely constructed object and can be difficult to discern.
It may leave the sub-class unable to construct its superclass or forced to
replicate the construction process completely within itself, losing the ability to call
super().  If the default constructor contains a call to an overridable method,
the subclass may be completely uninstantiable.   Note that this includes method calls
throughout the control flow graph - i.e., if a constructor Foo() calls a private method
bar() that calls a public method buz(), this denotes a problem.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
public class SeniorClass {
  public SeniorClass(){
      toString(); //may throw NullPointerException if overridden
  }
  public String toString(){
    return "IAmSeniorClass";
  }
}
public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass(){
    super(); //Automatic call leads to NullPointerException
    name = "JuniorClass";
  }
  public String toString(){
    return name.toUpperCase();
  }
}
  ]]>
      </example>
    </rule>

<!-- pohl: the accessor could be well intentioned...

    <rule name="AccessorClassGeneration"
    		 since="1.04"
          message="Avoid instantiation through private constructors from outside of the constructor's class."
          class="net.sourceforge.pmd.rules.AccessorClassGeneration"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AccessorClassGeneration">
      <description>
Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
A factory method, or non-privitization of the constructor can eliminate this situation.
The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
one with package scope, and is challenging to discern.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
public class Outer {
 void method(){
  Inner ic = new Inner();//Causes generation of accessor class
 }
 public class Inner {
  private Inner(){}
 }
}
  ]]>
      </example>
    </rule>
-->

    <rule name="FinalFieldCouldBeStatic"
    		 since="1.1"
          message="This final field could be made static"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#FinalFieldCouldBeStatic">
      <description>
If a final field is assigned to a compile-time constant, it could be
made static, thus saving overhead in each object at runtime.
      </description>
      <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    ]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  ]]>
      </example>
    </rule>


  <rule name="CloseResource"
  		  since="1.2.2"
        message="Ensure that resources like this {0} object are closed after use"
        class="net.sourceforge.pmd.rules.CloseResource"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#CloseResource">
    <description>
Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.
    </description>
    <priority>2</priority>
      <properties>
          <property name="types" value="Connection,Statement,ResultSet"/>
      </properties>
    <example>
<![CDATA[
public class Bar {
 public void foo() {
  Connection c = pool.getConnection();
  try {
    // do stuff
  } catch (SQLException ex) {
    // handle exception
  } finally {
    // oops, should close the connection using 'close'!
    // c.close();
  }
 }
}
]]>
    </example>
  </rule>

    <rule name="NonStaticInitializer"
    		  since="1.5"
           message="Non-static initializers are confusing"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonStaticInitializer">
       <description>
A nonstatic initializer block will be called any time a constructor
is invoked (just prior to invoking the constructor).  While this
is a valid language construct, it is rarely used and is confusing.
       </description>
       <priority>4</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Initializer[@Static='false']
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   ]]>
       </example>
     </rule>

    <rule name="DefaultLabelNotLastInSwitchStmt"
    		  since="1.5"
           message="The default label should be the last label in a switch statement"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#DefaultLabelNotLastInSwitchStmt">
       <description>
By convention, the default label should be the last label in a switch statement.
       </description>
       <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//SwitchStatement
 [not(SwitchLabel[position() = last()][@Default='true'])]
 [SwitchLabel[@Default='true']]
]]>
                 </value>
             </property>
         </properties>
       <example>
   <![CDATA[
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:  // do something
      break;
   default:  // the default case should be last, by convention
      break;
   case 2:
      break;
  }
 }
}   ]]>
       </example>
     </rule>

    <rule name="NonCaseLabelInSwitchStatement"
    		  since="1.5"
           message="A non-case label was present in a switch statement"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonCaseLabelInSwitchStatement">
       <description>
A non-case label (e.g. a named break/continue label) was present in a switch statement.
This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
       <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
 <![CDATA[
//SwitchStatement//BlockStatement/Statement/LabeledStatement
 ]]>
                 </value>
             </property>
         </properties>
       <example><![CDATA[
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   ]]></example>
     </rule>

    <rule name="OptimizableToArrayCall"
    		 since="1.8"
          message="This call to Collection.toArray() may be optimizable"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#OptimizableToArrayCall">
      <description>
A call to Collection.toArray can use the Collection's size vs an empty Array of the desired type.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]

                  ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
class Foo {
 void bar(Collection x) {
   // A bit inefficient
   x.toArray(new Foo[0]);
   // Much better; this one sizes the destination array, avoiding
   // a reflection call in some Collection implementations
   x.toArray(new Foo[x.size()]);
 }
}
  ]]>
      </example>
    </rule>


    <rule name="BadComparison"
    		 since="1.8"
          message="Avoid equality comparisons with Double.NaN"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#BadComparison">
      <description>
Avoid equality comparisons with Double.NaN - these are likely to be logic errors.
      </description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Bar {
 boolean x = (y == Double.NaN);
}
  ]]>
      </example>
    </rule>

    <rule name="EqualsNull"
    			since="1.9"
            message="Avoid using equals() to compare against null"
            class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EqualsNull">
        <description>
Inexperienced programmers sometimes confuse comparison concepts
and use equals() to compare to null.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
    <![CDATA[
//PrimaryExpression
 [
PrimaryPrefix/Name[ends-with(@Image, 'equals')]
or
PrimarySuffix[ends-with(@Image, 'equals')]
]
[PrimarySuffix/Arguments/ArgumentList[count(Expression)=1]
  /Expression/PrimaryExpression/PrimaryPrefix
   /Literal/NullLiteral]
    ]]>
                </value>
            </property>
         </properties>
    <example>
       <![CDATA[
class Bar {
   void foo() {
       String x = "foo";
       if (x.equals(null)) { // bad!
        doSomething();
       }
   }
}
    ]]>
        </example>
        </rule>

	<!-- pohl: This doesn't sound reasonable to me...
      <rule name="ConfusingTernary"
        since="1.9"
        message="Avoid if (x != y) ..; else ..;"
        class="net.sourceforge.pmd.rules.design.ConfusingTernary"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ConfusingTernary">
        <description>
In an "if" expression with an "else" clause, avoid negation in
the test.  For example, rephrase:
if (x != y) diff(); else same();
as:
if (x == y) same(); else diff();
Most "if (x != y)" cases without an "else" are often return
cases, so consistent use of this rule makes the code easier
to read.  Also, this resolves trivial ordering problems, such
as "does the error case go first?" or "does the common case
go first?".
        </description>
        <priority>5</priority>
        <example>
          <![CDATA[
public class Foo {
 boolean bar(int x, int y) {
  return (x != y) ? diff : same;
 }
}          ]]>
        </example>
      </rule>
	 -->

    <rule name="InstantiationToGetClass"
    		 since="2.0"
          message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#InstantiationToGetClass">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead.
      </description>
      <priority>2</priority>
        <properties>
          <property name="xpath">
            <value>
                <![CDATA[
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     ]]>
            </value>
          </property>
        </properties>
        <example>
    <![CDATA[
public class Foo {
 // Replace this
 Class c = new String().getClass();
 // with this:
 Class c = String.class;
}
    ]]>
        </example>
      </rule>

    <rule name="IdempotentOperations"
    		 since="2.0"
          message="Avoid idempotent operations (like assigning a variable to itself)."
          class="net.sourceforge.pmd.rules.IdempotentOperations"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#IdempotentOperations">
      <description>
Avoid idempotent operations - they are have no effect.
      </description>
        <priority>2</priority>

      <example>
      <![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
      ]]>
      </example>
    </rule>

	<!--
    <rule
        name="SimpleDateFormatNeedsLocale"
        since="2.0"
        message="When instantiating a SimpleDateFormat object, specify a Locale"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimpleDateFormatNeedsLocale">
        <description>
Be sure to specify a Locale when creating a new instance of SimpleDateFormat.
        </description>
        <priority>5</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//AllocationExpression
 [ClassOrInterfaceType[@Image='SimpleDateFormat']]
 [Arguments[@ArgumentCount=1]]
]]>
                    </value>
                 </property>
              </properties>
        <example>
        <![CDATA[
public class Foo {
 // Should specify Locale.US (or whatever)
 private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
}
        ]]>
        </example>
    </rule>
	-->

    <rule name="ImmutableField"
    		 since="2.0"
          message="Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor."
          class="net.sourceforge.pmd.rules.design.ImmutableField"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ImmutableField">
      <description>
Identifies private fields whose values never change once they are initialized either in the declaration of the field or by
a constructor.  This aids in converting existing classes to immutable classes.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Foo {
  private int x; // could be final
  public Foo() {
      x = 7;
  }
  public void foo() {
     int a = x + 2;
  }
}
  ]]>
      </example>
    </rule>

    <rule name="UseLocaleWithCaseConversions"
    		 since="2.0"
          message="When doing a String.toLowerCase()/toUpperCase() call, use a Locale"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseLocaleWithCaseConversions">
      <description>
When doing a String.toLowerCase()/toUpperCase() call, use a Locale.  This avoids
problems with certain locales, i.e. Turkish.
      </description>
      <priority>5</priority>
        <properties>
          <property name="xpath">
            <value>
                <![CDATA[
//PrimaryExpression
[PrimaryPrefix/Name
 [ends-with(@Image, 'toLowerCase') or ends-with(@Image,
'toUpperCase')]
 ]
[PrimarySuffix[position() = 1]/Arguments[@ArgumentCount=0]]
     ]]>
            </value>
          </property>
        </properties>
        <example>
    <![CDATA[
class Foo {
 // BAD
 if (x.toLowerCase().equals("list"))...
 /*
 This will not match "LIST" when in Turkish locale
 The above could be
 if (x.toLowerCase(Locale.US).equals("list")) ...
 or simply
 if (x.equalsIgnoreCase("list")) ...
 */
 // GOOD
 String z = a.toLowerCase(Locale.EN);
}
    ]]>
        </example>
    </rule>
	
	<!-- pohl: custom rule to enforce private class variables -->
	<rule name="MemberScope"
             message="All instance variable must be private."
             class="net.sourceforge.pmd.rules.XPathRule">
         <description>
All instance and class variables must be private. Class constants (which are static and final) can have other scopes.
         </description>
         <priority>2</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//FieldDeclaration[not(@Private='true' or (@Static='true' and @Final='true'))]
 ]]>
                 </value>
             </property>
         </properties>
        <example>
<![CDATA[
public class Bar {
 private int x;
 protected int y;  // <-- all members must be private!
 Bar() {}
}
 ]]>
         </example>
       </rule>

	<!--
    <rule name="AvoidProtectedFieldInFinalClass"
    			 since="2.1"
             message="Avoid protected fields in a final class.  Change to private or package access."
             class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidProtectedFieldInFinalClass">
         <description>
Do not use protected fields in final classes since they cannot be subclassed.
Clarify your intent by using private or package access modifiers instead.
         </description>
         <priority>3</priority>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Final='true']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected='true']
 ]]>
                 </value>
             </property>
         </properties>
        <example>
<![CDATA[
public final class Bar {
 private int x;
 protected int y;  // <- Bar cannot be subclassed, so is y really private or package visible???
 Bar() {}
}
 ]]>
         </example>
       </rule>
	-->

     <rule name="AssignmentToNonFinalStatic"
     		  since="2.2"
           message="Possible unsafe assignment to a non-final static field in a constructor."
           class="net.sourceforge.pmd.rules.design.AssignmentToNonFinalStatic"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AssignmentToNonFinalStatic">
       <description>
Identifies a possible unsafe usage of a static field.
       </description>
         <priority>4</priority>
       <example>
   <![CDATA[
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
   ]]>
       </example>
     </rule>

    <rule name="MissingStaticMethodInNonInstantiatableClass"
    		 since="3.0"
          message="Class cannot be instantiated and does not provide any static methods or fields"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#MissingStaticMethodInNonInstantiatableClass">
      <description>
A class that has private constructors and does not have any static methods or fields cannot be used.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Nested='false'][
( count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)>0
  and count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) = count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private='true']) )
and
count(.//MethodDeclaration[@Static='true'])=0
and
count(.//FieldDeclaration[@Private='false'][@Static='true'])=0
]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
/* This class is unusable, since it cannot be
 instantiated (private constructor),
 and no static method can be called.
 */
public class Foo {
 private Foo() {}
 void foo() {}
}

]]>
      </example>
    </rule>


    <rule name="AvoidSynchronizedAtMethodLevel"
    		 since="3.0"
          message="Use block level rather than method level synchronization"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidSynchronizedAtMethodLevel">
      <description>
  Method level synchronization can backfire when new code is added to the method.  Block-level
  synchronization helps to ensure that only the code that needs synchronization gets it.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration[@Synchronized='true']
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
 // Try to avoid this
 synchronized void foo() {
 }
 // Prefer this:
 void bar() {
  synchronized(this) {
  }
 }
}
]]>
      </example>
    </rule>

    <rule name="MissingBreakInSwitch"
    		 since="3.0"
          message="A switch statement does not contain a break"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#MissingBreakInSwitch">
      <description>
A switch statement without an enclosed break statement may be a bug.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//SwitchStatement
[count(.//BreakStatement)=0]
[count(SwitchLabel) > 0]
[count(BlockStatement/Statement/ReturnStatement)
 + count(BlockStatement/Statement/ThrowStatement)
     < count (SwitchLabel)]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
 public void bar(int status) {
  switch(status) {
   case CANCELLED:
    doCancelled();
    // break; hm, should this be commented out?
   case NEW:
    doNew();
   case REMOVED:
    doRemoved();
   }
 }
}
]]>
      </example>
    </rule>


    <rule name="UseNotifyAllInsteadOfNotify"
    		 since="3.0"
          message="Call Thread.notifyAll() rather than Thread.notify()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseNotifyAllInsteadOfNotify">
      <description>
Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
one is chosen.  The thread chosen is arbitrary; thus it's usually safer to call notifyAll() instead.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//StatementExpression/PrimaryExpression
[count(PrimarySuffix/Arguments/ArgumentList) = 0]
[
PrimaryPrefix[./Name[@Image='notify' or ends-with(@Image,'.notify')]
or @Image='notify'
or (./AllocationExpression and ../PrimarySuffix[@Image='notify'])
]
]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo {
 void bar() {
  x.notify();
  // If many threads are monitoring x, only one (and you won't know which) will be notified.
  // use instead:
  x.notifyAll();
 }
}
]]>
      </example>
    </rule>

    <rule name="AvoidInstanceofChecksInCatchClause"
    		 since="3.0"
          message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidInstanceofChecksInCatchClause">
      <description>
Each caught exception type should be handled in its own catch clause.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
try { // Avoid this
 // do something
} catch (Exception ee) {
 if (ee instanceof IOException) {
  cleanup();
 }
}
try {  // Prefer this:
 // do something
} catch (IOException ee) {
 cleanup();
}
]]>
      </example>
    </rule>

    <rule name="AbstractClassWithoutAbstractMethod"
    		 since="3.0"
          message="This abstract class does not have any abstract methods"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AbstractClassWithoutAbstractMethod">
      <description>
The abstract class does not contain any abstract methods. An abstract class suggests
an incomplete implementation, which is to be completed by subclasses implementing the
abstract methods. If the class is intended to be used as a base class only (not to be instantiated
direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
  [count(.//ExtendsList)=0]
              ]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public abstract class Foo {
 void int method1() { ... }
 void int method2() { ... }
 // consider using abstract methods or removing
 // the abstract modifier and adding protected constructors
}
]]>
      </example>
    </rule>

    <rule name="SimplifyConditional"
    		 since="3.1"
              message="No need to check for null before an instanceof"
              class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyConditional">
          <description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
          </description>
          <priority>3</priority>
          <properties>
              <property name="xpath">
                  <value>
                      <![CDATA[
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      /PrimaryExpression/PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression/PrimaryExpression/PrimaryPrefix/Name/@Image]]]
 ]]>
                  </value>
              </property>
          </properties>
           <example>
      <![CDATA[
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      ]]>
           </example>
        </rule>

<rule  name="CompareObjectsWithEquals"
  since="3.2"
  message="Use equals() to compare object references."
  class="net.sourceforge.pmd.rules.design.CompareObjectsWithEquals"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#CompareObjectsWithEquals">
  <description>
 Use equals() to compare object references; avoid comparing them with ==.
  </description>
  <priority>3</priority>
  <example>
<![CDATA[
class Foo {
 boolean bar(String a, String b) {
  return a == b;
 }
}

]]>
  </example>
</rule>


<rule name="PositionLiteralsFirstInComparisons"
  since="3.3"
  message="Position literals first in String comparisons"
  class="net.sourceforge.pmd.rules.XPathRule"
  externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#PositionLiteralsFirstInComparisons">
  <description>
 Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false.
  </description>
  <priority>3</priority>
  <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//PrimaryExpression[
        PrimaryPrefix[Name
                [
	(ends-with(@Image, '.equals'))
                ]
        ]
        [
                   (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal)
	and
	( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )
        ]
]
[not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
[not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]

          ]]>
          </value>
      </property>
  </properties>
  <example>
<![CDATA[
class Foo {
 boolean bar(String x) {
  return x.equals("2"); // should be "2".equals(x)
 }
}

]]>
  </example>
</rule>

    <rule name="UnnecessaryLocalBeforeReturn"
          since="3.3"
          message="Consider simply returning the value vs storing it in local variable ''{0}''"
          class="net.sourceforge.pmd.rules.design.UnnecessaryLocalBeforeReturn"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UnnecessaryLocalBeforeReturn">
      <description>
Avoid unnecessarily creating local variables
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
  public class Foo {
    public int foo() {
      int x = doSomething();
      return x;  // instead, just 'return doSomething();'
    }
  }
  ]]>
      </example>
    </rule>

    <rule name="NonThreadSafeSingleton"
    since="3.4"
    message="Singleton is not thread safe"
    class="net.sourceforge.pmd.rules.design.NonThreadSafeSingleton"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonThreadSafeSingleton">
        <description>
Non-thread safe singletons can result in bad state changes. Eliminate
static singletons if possible by instantiating the object directly. Static
singletons are usually not needed as only a single instance exists anyway.
Other possible fixes are to synchronize the entire method or to use an
initialize-on-demand holder class (do not use the double-check idiom).

See Effective Java, item 48.
        </description>
        <priority>3</priority>
        <properties>
            <property name="checkNonStaticMethods"
                description="Do not set this to false and checkNonStaticFields to true">
                <value>true</value>
            </property>
            <property name="checkNonStaticFields"
                description="Do not set this to true and checkNonStaticMethods to false">
                <value>false</value>
            </property>
        </properties>
        <example><![CDATA[
private static Foo foo = null;

//multiple simultaneous callers may see partially initialized objects
public static Foo getFoo() {
    if (foo==null)
        foo = new Foo();
    return foo;
}
        ]]></example>
    </rule>


	<!-- pohl: all emtpy blocks have to commented -->
    <rule name="UncommentedEmptyBlock"
          since="3.4"
          message="Empty and uncommented block"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UncommentedEmptyMethod">
      <description>
By explicitly commenting empty blocks
it is easier to distinguish between intentional (commented) and unintentional
empty block.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Block[count(BlockStatement) = 0 and @containsComment = 'false']
 ]]>
             </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public void doSomething() {
}
 ]]>
      </example>
    </rule>

    <rule name="UncommentedEmptyConstructor"
          since="3.4"
          message="Document empty constructor"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UncommentedEmptyConstructor">
      <description>
Uncommented Empty Constructor finds instances where a constructor does not
contain statements, but there is no comment. By explicitly commenting empty
constructors it is easier to distinguish between intentional (commented)
and unintentional empty constructors.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and ($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false']
 ]]>
             </value>
          </property>
          <property name="ignoreExplicitConstructorInvocation" description="Ignore explicit constructor invocation when deciding whether constructor is empty or not">
              <value>false</value>
          </property>
      </properties>
      <example>
  <![CDATA[
public Foo() {
  super();
}
 ]]>
      </example>
    </rule>

<rule name="AvoidConstantsInterface"
      since="3.5"
      message="An Interface should be used only to model a behaviour; consider converting this to a class."
      class="net.sourceforge.pmd.rules.XPathRule"
      externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidConstantsInterface">
      <description>
     An interface should be used only to model a behaviour of a
    class: using an interface as a container of constants is a poor usage pattern.
      </description>
      <priority>4</priority>
      <properties>
        <property name="xpath">
        <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Interface="true"]
    [
     count(.//MethodDeclaration)=0
     and
     count(.//FieldDeclaration)>0
    ]
    ]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
    public interface ConstantsInterface {
     public static final int CONSTANT1=0;
     public static final String CONSTANT2="1";
    }
    ]]>
      </example>
    </rule>

  <rule name="UnsynchronizedStaticDateFormatter"
      since="3.6"
      message="Static DateFormatter objects should be accessed in a synchronized manner"
      class="net.sourceforge.pmd.rules.design.UnsynchronizedStaticDateFormatter"
      externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UnsynchronizedStaticDateFormatter">
      <description>
SimpleDateFormat is not synchronized. Sun recomends separate format instances
for each thread. If multiple threads must access a static formatter, the
formatter must be synchronized either on method or block level.
      </description>
      <priority>2</priority>
      <example>
    <![CDATA[
public class Foo {
    private static final SimpleDateFormat sdf = new SimpleDateFormat();
    void bar() {
        sdf.format(); // bad
    }
    synchronized void foo() {
        sdf.format(); // good
    }
}
    ]]>
      </example>
    </rule>

  <rule name="PreserveStackTrace"
      since="3.7"
      message="New exception is thrown in catch block, original stack trace may be lost"
      class="net.sourceforge.pmd.rules.design.PreserveStackTrace"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#PreserveStackTrace">
      <description>
Throwing a new exception from a catch block without passing the original exception into the
new exception will cause the true stack trace to be lost, and can make it difficult to
debug effectively.
      </description>
      <priority>2</priority>
      <example>
    <![CDATA[
public class Foo {
    void good() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e);
        }
    }
    void bad() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e.getMessage());
        }
    }
}
    ]]>
      </example>
    </rule>

    <rule name="UseCollectionIsEmpty"
         since="3.9"
         message="Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()"
         class="net.sourceforge.pmd.rules.design.UseCollectionIsEmpty"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseCollectionIsEmpty">
         <description>
The isEmpty() method on java.util.Collection is provided to see if a collection has any elements.
Comparing the value of size() to 0 merely duplicates existing behavior.
      </description>
      <priority>4</priority>
      <example>
    <![CDATA[
	public class Foo {
		void good() {
        	List foo = getList();
			if (foo.isEmpty()) {
				// blah
			}
    	}

	    void bad() {
    	    List foo = getList();
				if (foo.size() == 0) {
					// blah
				}
	    	}
	}
    ]]>
      </example>
    </rule>

    <rule name="ClassWithOnlyPrivateConstructorsShouldBeFinal"
          since="4.1"
          class="net.sourceforge.pmd.rules.XPathRule"
          message="A class which only has private constructors should be final"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ClassWithOnlyPrivateConstructorsShouldBeFinal">
        <description>
A class with only private constructors should be final, unless the private
constructor is called by a inner class.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
TypeDeclaration[count(../TypeDeclaration) = 1]/ClassOrInterfaceDeclaration
[@Final = 'false']
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private = 'true']) >= 1 ]
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[(@Public = 'true') or (@Protected = 'true') or (@PackagePrivate = 'true')]) = 0]
[not(.//ClassOrInterfaceDeclaration)]
             ]]></value>
            </property>
        </properties>
        <example><![CDATA[
public class Foo {  //Should be final
    private Foo() { }
}
     ]]></example>
    </rule>


	<!-- pohl: this might have to be reviewed as doing nothing could be the default behaviour -->
    <rule name="EmptyMethodInAbstractClassShouldBeAbstract"
          since="4.1"
          class="net.sourceforge.pmd.rules.XPathRule"
          message="An empty method in an abstract class should be abstract instead"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EmptyMethodInAbstractClassShouldBeAbstract">
        <description>
An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation
rather than code the appropriate one.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                <![CDATA[
                    //ClassOrInterfaceDeclaration[@Abstract = 'true']
                        /ClassOrInterfaceBody
                        /ClassOrInterfaceBodyDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='Override'])=0]
                        /MethodDeclaration[@Abstract = 'false' and @Native = 'false']
                        [
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral) = 'true' )
                            or
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '0']) = 'true' )
                    		or
							( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) = 2]) = 'true' )
							or
							(
								(
									(boolean(./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '']) = 'true' )
								)
								and
								( count (./Block/*) = 1 )
							)
                            or
                            ( count (./Block/*) = 0 )
                        ]
                ]]>
             </value>
            </property>
        </properties>
        <example>
        	<![CDATA[
				public abstract class ShouldBeAbstract
				{
				    public Object couldBeAbstract()
				    {
					// Should be abstract method ?
					return null;
				   	}

				    public void couldBeAbstract()
				    {
				    }
				}
	     	]]>
    	</example>
    </rule>

    <rule name="SingularField"
          since="3.1"
          message="Perhaps ''{0}'' could be replaced by a local variable."
          class="net.sourceforge.pmd.rules.design.SingularField"
      	externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SingularField">
		<description>
      		<![CDATA[
This field is used in only one method and the first usage is assigning a value
to the field. This probably means that the field can be changed to a local variable.
			]]>
      </description>
      <priority>1</priority>
      <properties>
		<!-- Disabled by default because these options generate false positives -->
		<property name="CheckInnerClasses" description="Check inner classes">
            <value>false</value>
        </property>
        <property name="DisallowNotAssignment" description="Disallow violations where the first usage is not an assignment">
            <value>false</value>
        </property>
      </properties>
      <example><![CDATA[
public class Foo {
    private int x;  //Why bother saving this?
    public void foo(int y) {
     x = y + 5;
     return x;
    }
}
   ]]></example>
    </rule>

    <rule	name="ReturnEmptyArrayRatherThanNull"
         since="4.2"
        	class="net.sourceforge.pmd.rules.XPathRule"
        	message="Return an empty array rather than 'null'."
        	externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ReturnEmptyArrayRatherThanNull">
        <description>
            <![CDATA[
            For any method that returns an array, it's a better behavior to return an empty array rather than a null reference.
            ]]>
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
                        //MethodDeclaration
                        [
                        (./ResultType/Type[@Array='true'])
                        and
                        (./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral)
                        ]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            public class Example
            {
                // Not a good idea...
                public int []badBehavior()
                {
                    // ...
                    return null;
                }

                // Good behavior
                public String[] bonnePratique()
                {
                    //...
                    return new String[0];
                }
            }
            ]]>
        </example>
    </rule>

    <rule	name="AbstractClassWithoutAnyMethod"
         since="4.2"
        	class="net.sourceforge.pmd.rules.XPathRule"
        	message="No abstract method which means that the  keyword is most likely used to prevent instantiation. use a private or protected constructor instead."
        	externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AbstractClassWithoutAnyMethod">
        <description>
            <![CDATA[
			If the abstract class does not provides any methods, it may be just a data container that is not to be instantiated. In this case, it's probably
			better to use a private or a protected constructor in order to prevent instantiation than make the class misleadingly abstract.
            ]]>
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration[
	(@Abstract = 'true')
	and
	(count(//MethodDeclaration) + count(//ConstructorDeclaration) = 0)
]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class abstract Example {
	String field;
	int otherField;
}
            ]]>
        </example>
    </rule>

	<rule	name="TooFewBranchesForASwitchStatement"
		since="4.2"
		class="net.sourceforge.pmd.rules.XPathRule"
		message="A switch with less than 3 branches is inefficient, use a if statement instead."
		externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#TooFewBranchesForASwitchStatement">
	    <description>
		    <![CDATA[
			     Swith are designed complex branches, and allow branches to share treatement. Using a switch for only a few 
			     branches is ill advised, as switches are not as easy to understand as if. In this case, it's most likely
			     is a good idea to use a if statement instead, at least to increase code readability.
			     ]]>
	    </description>
	    <priority>3</priority>
	    <properties>
		    <property name="minimumNumberCaseForASwitch" description="Minimum number of branches for a switch" value="3"/>
		    <property name="xpath">
			    <value>
				    <![CDATA[
					     //SwitchStatement[
					     (count(.//SwitchLabel) < $minimumNumberCaseForASwitch)
								      ]
								      ]]>
					     </value>
				     </property>
			     </properties>
			     <example>
				     <![CDATA[
// With a minimumNumberCaseForASwitch of 3	    
public class Foo {
	public void bar() {
		switch (condition) {
			case ONE:
				instruction;
				break;
			default:
				break; // not enough for a 'switch' stmt, a simple 'if' stmt would have been more appropriate
		}
	}
}
					      ]]>
			     </example>
	</rule>

<!--
	<rule 	name="TooManyHttpFilter"
	         since="4.2"
          	message="Too many Http Filter inside a web application can make very it complex to understand and to deploy."
          	class="net.sourceforge.pmd.rules.design.GenericClassCounterRule"
      		externalInfoUrl="http://pmd.sourceforge.net/rules/controversial.html#TooManyHttpFilter">
		<description>
			<![CDATA[
The Http Filter are generally used to create session for the Object Relation Mapping tools and for security purpose or logging. Too many of them may
lead to a complex architecture where everything is by "intercepting" the http request (pretty like aspect programming object). It can be elegant but
far too complex.
			]]>
		</description>
		<priority>4</priority>
		<properties>
		 -->
			<!-- Must be a full java name to ensure type control !!! -->
			<!--
			<property 	name="typeMatch"
						description="A series of regex to match on implements/extends classname"
						value="javax.servlet.Filter,javax.servlet.HttpFilter"/>
						 -->
			<!-- Define after how many occurences one should log a violation -->
<!--
			<property 	name="threshold"
						description="Defines how many occurences are legal"
						value="2"/>
      	</properties>
		<example>
			<![CDATA[
import javax.servlet.Filter;

public class FooFilter implements Filter
{
	public FooFilter() { }

	private class OneTooMuchFilter implements Filter {}

}
			]]>
		</example>
	</rule>
	 -->
	 
	<!-- rules adapted from the PMD (4.2.5) 'finalizers.xml' -->
	
	   <rule name="EmptyFinalizer"
    		 since="1.5"
          message="Avoid empty finalize methods"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#EmptyFinalizer">
       <description>
If the finalize() method is empty, then it does not need to exist.
       </description>
       <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
  /Block[count(*)=0]
]]>
                </value>
            </property>
        </properties>
       <example>
<![CDATA[
public class Foo {
   protected void finalize() {}
}
]]>
       </example>
     </rule>

    <rule name="FinalizeOnlyCallsSuperFinalize"
    		 since="1.5"
          message="Finalize should do something besides just calling super.finalize()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeOnlyCallsSuperFinalize">
       <description>
If the finalize() is implemented, it should do something besides just calling
super.finalize().
       </description>
       <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[MethodDeclarator[@Image="finalize"][not(FormalParameters/*)]]
   /Block[count(BlockStatement)=1]
     /BlockStatement[
       Statement/StatementExpression/PrimaryExpression
      /PrimaryPrefix[@Image="finalize"]
      ]
]]>
                </value>
            </property>
        </properties>
       <example>
           <![CDATA[
public class Foo {
   protected void finalize() {
     super.finalize();
   }
}
           ]]>
       </example>
     </rule>

<rule name="FinalizeOverloaded"
		since="1.5"
      message="Finalize methods should not be overloaded"
      class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeOverloaded">
   <description>
Methods named finalize() should not have parameters.  It is
confusing and probably a bug to overload finalize().  It will
not be called by the VM.
   </description>
   <priority>2</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//MethodDeclaration
 /MethodDeclarator[@Image='finalize'][FormalParameters[count(*)>0]]
]]>
            </value>
        </property>
    </properties>
   <example>
<![CDATA[
public class Foo {
   // this is confusing and probably a bug
   protected void finalize(int a) {
   }
}
]]>
   </example>
 </rule>

    <rule name="FinalizeDoesNotCallSuperFinalize"
    		 since="1.5"
          message="Last statement in finalize method should be a call to super.finalize()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeDoesNotCallSuperFinalize">
       <description>
If the finalize() is implemented, its last action should be to call super.finalize.
       </description>
       <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<!-- in english: a method declaration of finalize(), with no arguments, containing
a block whose last statement is NOT a call to super.finalize -->
<![CDATA[
//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
   /Block
      /BlockStatement[last()]
      [not(Statement/StatementExpression/PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
      [not(Statement/TryStatement/FinallyStatement
       /Block/BlockStatement/Statement/StatementExpression
        /PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
]]>
                </value>
            </property>
        </properties>
       <example>
<![CDATA[
public class Foo {
   protected void finalize() {
       something();
       // neglected to call super.finalize()
   }
}
]]>
       </example>
     </rule>

    <rule name="FinalizeShouldBeProtected"
    		 since="1.1"
          message="If you override finalize(), make it protected"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeShouldBeProtected">
      <description>
If you override finalize(), make it protected.  If you make
 it public, other classes may call it.
      </description>
      <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    ]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
public class Foo {
 public void finalize() {
  // do something
 }
}
  ]]>
      </example>
    </rule>


    <rule name="AvoidCallingFinalize"
    		 since="3.0"
          message="Avoid calling finalize() explicitly"
          class="net.sourceforge.pmd.rules.AvoidCallingFinalize"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#AvoidCallingFinalize">
      <description>
Object.finalize() is called by the garbage collector on an object when garbage collection determines
that there are no more references to the object.
      </description>
        <priority>2</priority>
      <example>
<![CDATA[
public class Foo {
 void foo() {
  Bar b = new Bar();
  b.finalize();
 }
}
]]>
      </example>
    </rule>
	
	<!-- rules adapted from PMD (4.2.5) 'imports.xml' -->
	
  <rule name="DuplicateImports"
  		  since="0.5"
        message="Avoid duplicate imports such as ''{0}''"
        class="net.sourceforge.pmd.rules.imports.DuplicateImportsRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#DuplicateImports">
    <description>
    Avoid duplicate import statements.
    </description>
      <priority>4</priority>
    <example>
<![CDATA[
import java.lang.String;
import java.lang.*;
public class Foo {}
]]>
    </example>
    </rule>

  <rule name="DontImportJavaLang"
  		  since="0.5"
        message="Avoid importing anything from the package 'java.lang'"
        class="net.sourceforge.pmd.rules.imports.DontImportJavaLang"
          externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#DontImportJavaLang">
    <description>
Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    </description>
      <priority>4</priority>
    <example>
<![CDATA[
// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}
]]>
    </example>
    </rule>

  <rule name="UnusedImports"
  		  since="1.0"
        message="Avoid unused imports such as ''{0}''"
        class="net.sourceforge.pmd.rules.imports.UnusedImportsRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#UnusedImports">
    <description>
    Avoid unused import statements.
    </description>
      <priority>4</priority>
    <example>
<![CDATA[
// this is bad
import java.io.File;
public class Foo {}
]]>
    </example>
    </rule>

    <rule name="ImportFromSamePackage"
    		since="1.02"
         message="No need to import a type that lives in the same package"
         class="net.sourceforge.pmd.rules.imports.ImportFromSamePackageRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#ImportFromSamePackage">
     <description>
 No need to import a type that lives in the same package.
     </description>
        <priority>3</priority>
     <example>
 <![CDATA[
 package foo;
 import foo.Buz; // no need for this
 import foo.*; // or this
 public class Bar{}
 ]]>
     </example>
     </rule>

	<rule name="DoNotUseStaticImports"
	      since="4.1"
        	class="net.sourceforge.pmd.rules.XPathRule"
        	message="Do not use static imports.">
       		<description><![CDATA[
Using the static import feature, it can make your program unreadable and 
unmaintainable, polluting its namespace with all the static members you import. 
Readers of your code (including you, a few months after you wrote it) will not know 
which class a static member comes from (Sun 1.5 Language Guide).
		 ]]></description>
			<priority>3</priority>
       		<properties>
	            <property name="xpath">
	                <value><![CDATA[
.[count(ImportDeclaration[@Static = 'true']) > 0]
	             ]]></value>
	            </property>
	        </properties>
    	 	<example><![CDATA[
import static Lennon;
import static Ringo;
import static George;
import static Paul;
import static Yoko; // Too much !
		  ]]></example>
    </rule>
	
	<!-- pohl: custom rule -->
	<rule name="DoNotUseImportWildcards"
	      since="4.1"
        	class="net.sourceforge.pmd.rules.XPathRule"
        	message="Do not use import wildcards. Keep your code explicit.">
       		<description>Do not use import wildcards. Keep your code explicit.</description>
			<priority>3</priority>
       		<properties>
	            <property name="xpath">
	                <value><![CDATA[
//ImportDeclaration[@ImportedName=@PackageName]
	             ]]></value>
	            </property>
	        </properties>
    	 	<example><![CDATA[
import java.util.*; // Please no!
import java.awt.*; // Which List to use now?
		  ]]></example>
    </rule>

	
	<!-- rules adapted from PMD (4.2.5) 'javabeans.xml' -->
	
	<!-- pohl: not used -->
	
	
	<!-- pohl: this rule triggers false negatives so I commented it out
	
  <rule name="BeanMembersShouldSerialize"
  		  since="1.1"
        message="Found non-transient, non-static member. Please mark as transient or provide accessors."
        class="net.sourceforge.pmd.rules.BeanMembersShouldSerializeRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/javabeans.html#BeanMembersShouldSerialize">
    <description>
If a class is a bean, or is referenced by a bean directly or indirectly
it needs to be serializable. Member variables need to be marked as transient,
static, or have accessor methods in the class. Marking variables
as transient is the safest and easiest modification. Accessor methods should
follow the Java naming conventions, i.e.if you have a variable foo, you should
provide getFoo and setFoo methods.
    </description>
      <priority>3</priority>
      <properties>
          <property name="prefix" description="A variable prefix to skip, i.e., m_" value=""/>
      </properties>
    <example>
<![CDATA[
  private transient int someFoo;//good, it's transient
  private static int otherFoo;// also OK
  private int moreFoo;// OK, has proper accessors, see below
  private int badFoo;//bad, should be marked transient


  private void setMoreFoo(int moreFoo){
        this.moreFoo = moreFoo;
  }

  private int getMoreFoo(){
        return this.moreFoo;
  }

]]>
    </example>
  </rule>
  
  -->
	
    <rule name="MissingSerialVersionUID"
    		 since="3.0"
          message="Classes implementing Serializable should set a serialVersionUID"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/javabeans.html#MissingSerialVersionUID">
      <description>
Classes that are serializable should provide a serialVersionUID field.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration
 [
  count(ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
   /FieldDeclaration/VariableDeclarator/VariableDeclaratorId[@Image='serialVersionUID']) = 0
and
  count(ImplementsList
   [ClassOrInterfaceType/@Image='Serializable'
   or ClassOrInterfaceType/@Image='java.io.Serializable']) =1
and
   @Abstract = 'false'
]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class Foo implements java.io.Serializable {
 String name;
 // Define serialization id to avoid serialization related bugs
 // i.e., public static final long serialVersionUID = 4328743;
}

]]>
          </example>
    </rule>
	
	
	<!-- rules adapted from PMD (4.2.5) 'junit.xml' ruleset -->
	
	
    <rule name="JUnitStaticSuite"
    		 since="1.0"
          message="You have a suite() method that is not both public and static, so JUnit won't call it to get your TestSuite.  Is that what you wanted to do?"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#JUnitStaticSuite">
      <description>
The suite() method in a JUnit test needs to be both public and static.
      </description>
      <priority>3</priority>
        <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//MethodDeclaration[not(@Static='true') or not(@Public='true')]
[MethodDeclarator/@Image='suite']
[MethodDeclarator/FormalParameters/@ParameterCount=0]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
                ]]>
            </value>
        </property>
        </properties>
      <example>
  <![CDATA[
import junit.framework.*;
public class Foo extends TestCase {
 public void suite() {} // oops, should be static
 private static void suite() {} // oops, should be public
}
  ]]>
      </example>
      </rule>

	  <!-- this is old school junit. You normally do this by annotation. -->
  <rule name="JUnitSpelling"
  		  since="1.0"
        message="You may have misspelled a JUnit framework method (setUp or tearDown)"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#JUnitSpelling">
    <description>
Some JUnit framework methods are easy to misspell.
    </description>
    <priority>3</priority>
      <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//MethodDeclarator[(not(@Image = 'setUp')
 and translate(@Image, 'SETuP', 'setUp') = 'setUp')
 or (not(@Image = 'tearDown')
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
              ]]>
          </value>
      </property>
      </properties>
    <example>
<![CDATA[
import junit.framework.*;
public class Foo extends TestCase {
 public void setup() {} // oops, should be setUp
 public void TearDown() {} // oops, should be tearDown
}
]]>
    </example>
    </rule>

    <rule name="JUnitTestsShouldIncludeAssert"
    		 since="2.0"
          message="JUnit tests should include assert() or fail() or verify()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#JUnitTestsShouldIncludeAssert">
        <description>
JUnit tests should include at least one assertion.  This makes the tests more robust, and
 using assert with messages provide the developer a clearer idea of what the test does.
        </description>
          <priority>4</priority>
          <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//ClassOrInterfaceDeclaration
[
@Interface='false'
and (ends-with(@Image, 'Test'))
]
//ClassOrInterfaceBodyDeclaration
[
.//MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]
and not(
.//StatementExpression/PrimaryExpression
[
starts-with(.//PrimaryPrefix/Name/@Image,'assert')
or
starts-with(.//PrimarySuffix/@Image,'assert')
or
starts-with(.//PrimaryPrefix/Name/@Image,'Assert.assert')
or
starts-with(.//PrimaryPrefix/Name/@Image,'Assertions.assert')
or
starts-with(.//PrimarySuffix/@Image,'Assert.assert')
or
starts-with(.//PrimaryPrefix/Name/@Image,'fail')
or
starts-with(.//PrimarySuffix/@Image,'fail')
or
starts-with(.//PrimaryPrefix/Name/@Image,'Assert.fail')
or
starts-with(.//PrimarySuffix/@Image,'Assert.fail')
or
starts-with(.//PrimaryPrefix/Name/@Image,'verify')
or
starts-with(.//PrimarySuffix/@Image,'verify')
or
starts-with(.//PrimaryPrefix/Name/@Image,'Mockito.verify')
or
starts-with(.//PrimarySuffix/@Image,'Mockito.verify')
])]
              ]]>
          </value>
      </property>
      </properties>
        <example>
    <![CDATA[
public class FooTest {
  @Test
  public void testSomething() {
      Bar b = findBar();
  // This is better than having a NullPointerException
  // assertNotNull("bar not found", b);
  b.work();
  }
}
    ]]>
        </example>
      </rule>

    <rule name="TestClassWithoutTestCases"
    		 since="3.0"
          message="This class name ends with 'Test' but contains no test cases"
          class="net.sourceforge.pmd.rules.junit.TestClassWithoutTestCases"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#TestClassWithoutTestCases">
      <description>
Test classes end with the suffix Test. Having a non-test class with that name is
not a good practice, since most people will assume it is a test case. Test
classes have test methods named testXXX.
      </description>
        <priority>3</priority>
      <example>
<![CDATA[
//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest {
   public static void main(String[] args) {
    // do something
   }
   // code
}
]]>
      </example>
    </rule>

    <rule name="UnnecessaryBooleanAssertion"
    		 since="3.0"
          message="assertTrue(true) or similar statements are unnecessary"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#UnnecessaryBooleanAssertion">
      <description>
A JUnit test assertion with a boolean literal is unnecessary since it always will eval to the same thing.
Consider using flow control (in case of assertTrue(false) or similar) or simply removing
statements like assertTrue(true) and assertFalse(false).  If you just want a test to halt, use the fail method.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//StatementExpression
[
.//Name[@Image='assertTrue' or  @Image='assertFalse']
and
PrimaryExpression/PrimarySuffix/Arguments/ArgumentList
 /Expression/PrimaryExpression/PrimaryPrefix
  /Literal/BooleanLiteral
or
(
.//Name[@Image='assertTrue' or  @Image='assertFalse']
and
PrimaryExpression/PrimarySuffix/Arguments/ArgumentList
 /Expression/UnaryExpressionNotPlusMinus[@Image='!']
/PrimaryExpression/PrimaryPrefix[Literal/BooleanLiteral or Name[count(../../*)=1]])
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class SimpleTest extends TestCase {
 public void testX() {
  // Why on earth would you write this?
  assertTrue(true);
 }
}
]]>
          </example>
    </rule>

    <rule name="UseAssertEqualsInsteadOfAssertTrue"
    		 since="3.1"
          message="Use assertEquals(x, y) instead of assertTrue(x.equals(y))"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#UseAssertEqualsInsteadOfAssertTrue">
      <description>
This rule detects JUnit assertions in object equality. These assertions
should be made by more specific methods, like assertEquals.
      </description>
      <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//PrimaryExpression[
    PrimaryPrefix/Name[@Image = 'assertTrue']
][
    PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
    [ends-with(@Image, '.equals')]
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
 ]]>
            </value>
        </property>
    </properties>
      <example>
<![CDATA[
public class FooTest extends TestCase {
 void testCode() {
  Object a, b;
  assertTrue(a.equals(b)); // bad usage
  assertEquals(?a should equals b?, a, b); // good usage
 }
}
]]>
      </example>
    </rule>

   <rule name="UseAssertSameInsteadOfAssertTrue"
   		 since="3.1"
          message="Use assertSame(x, y) instead of assertTrue(x==y), or assertNotSame(x,y) vs assertFalse(x==y)"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#UseAssertSameInsteadOfAssertTrue">
      <description>
This rule detects JUnit assertions in object references equality. These assertions
should be made by more specific methods, like assertSame, assertNotSame.
      </description>
      <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//PrimaryExpression[
    PrimaryPrefix/Name
     [@Image = 'assertTrue' or @Image = 'assertFalse']
]
[PrimarySuffix/Arguments
 /ArgumentList/Expression
 /EqualityExpression[count(.//NullLiteral) = 0]]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
 ]]>
            </value>
        </property>
    </properties>
      <example>
<![CDATA[
public class FooTest extends TestCase {
 void testCode() {
  Object a, b;
  assertTrue(a==b); // bad usage
  assertSame(a, b);  // good usage
 }
}
]]>
      </example>
    </rule>

    <rule name="UseAssertNullInsteadOfAssertTrue"
           since="3.5"
           message="Use assertNull(x) instead of assertTrue(x==null), or assertNotNull(x) vs assertFalse(x==null)"
           class="net.sourceforge.pmd.rules.XPathRule"
           externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#UseAssertNullInsteadOfAssertTrue">
       <description>
 This rule detects JUnit assertions in object references equality. These assertions
 should be made by more specific methods, like assertNull, assertNotNull.
       </description>
       <priority>3</priority>
     <properties>
         <property name="xpath">
             <value>
                 <![CDATA[
//PrimaryExpression[
 PrimaryPrefix/Name[@Image = 'assertTrue' or @Image = 'assertFalse']
][
 PrimarySuffix/Arguments/ArgumentList[
  Expression/EqualityExpression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
 ]
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
  ]]>
             </value>
         </property>
     </properties>
       <example>
 <![CDATA[
 public class FooTest extends TestCase {
  void testCode() {
   Object a = doSomething();
   assertTrue(a==null); // bad usage
   assertNull(a);  // good usage
   assertTrue(a != null); // bad usage
   assertNotNull(a);  // good usage
  }
 }
 ]]>
       </example>
     </rule>

    <rule name="SimplifyBooleanAssertion"
       since="3.6"
	    message="assertTrue(!expr) can be replaced by assertFalse(expr)"
        class="net.sourceforge.pmd.rules.XPathRule"
       externalInfoUrl="http://pmd.sourceforge.net/rules/junit.html#SimplifyBooleanAssertion">
      <description>
Avoid negation in an assertTrue or assertFalse test.
For example, rephrase:
assertTrue(!expr);
as:
assertFalse(expr);
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//StatementExpression
[
.//Name[@Image='assertTrue' or  @Image='assertFalse']
and
PrimaryExpression/PrimarySuffix/Arguments/ArgumentList
 /Expression/UnaryExpressionNotPlusMinus[@Image='!']
/PrimaryExpression/PrimaryPrefix
]
[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType[typeof(@Image, 'junit.framework.TestCase','TestCase')] or //MarkerAnnotation/Name[typeof(@Image, 'org.junit.Test', 'Test')]]]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class SimpleTest extends TestCase {
 public void testX() {
  assertTrue("not empty", !r.isEmpty()); // replace with assertFalse("not empty", r.isEmpty())
  assertFalse(!r.isEmpty()); // replace with assertTrue(r.isEmpty())
 }
}
]]>
          </example>
    </rule>
	
	
	<!-- rules adapted from PMD (4.2.5) 'logging-jakarta-commons.xml' and 'logging-java.xml' (both customized to fit to Log4J) -->
	
	<!-- TODO: this rule is not working as intended IMHO -->
	<rule name="UseCorrectExceptionLogging"
		  since="3.2"
        message="Use the correct logging statement for logging exceptions"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/logging-jakarta-commons.html#UseCorrectExceptionLogging">
		<description>
To make sure the full stacktrace is printed out, use the logging statement with 2 arguments: a String and a Throwable.
        </description>
        <priority>2</priority>
	   	<properties>
			<property name="xpath">
				<value><![CDATA[
//CatchStatement/Block/BlockStatement/Statement/StatementExpression
/PrimaryExpression[PrimaryPrefix/Name[starts-with(@Image,
concat(ancestor::ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[Type//ClassOrInterfaceType[@Image='Log' or @Image='Logger']]
/VariableDeclarator/VariableDeclaratorId/@Image, '.'))]]
[PrimarySuffix/Arguments[@ArgumentCount='1']]
[PrimarySuffix/Arguments//Name/@Image = ancestor::CatchStatement/FormalParameter/VariableDeclaratorId/@Image]
         ]]></value>
			</property>
		</properties>
		<example><![CDATA[
public class Main {
 private static final Log _LOG = LogFactory.getLog( Main.class );
 void bar() {
  try {
  } catch( Exception e ) {
   _LOG.error( e ); //Wrong!
  } catch( OtherException oe ) {
   _LOG.error( oe.getMessage(), oe ); //Correct
  }
 }
}
]]></example>
	</rule>
	
	
	<rule name="LoggerIsNotStaticFinal"
     		since="2.0"
         message="The Logger variable declaration does not contain the static and final modifiers"
         class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#LoggerIsNotStaticFinal">
     <description>
In most cases, the Logger can be declared static and final.
     </description>
     <priority>2</priority>
     <properties>
         <property name="xpath">
             <value>
                 <![CDATA[
//VariableDeclarator
 [parent::FieldDeclaration]
 [../Type/ReferenceType
  /ClassOrInterfaceType[@Image='Logger']
   and
  (..[@Final='false'] or ..[@Static = 'false'] ) ]
                ]]>
             </value>
         </property>
     </properties>
     <example>
 <![CDATA[
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is much better to declare the logger as follows 
    // static final Logger log = Logger.getLogger(Foo.class.getName());
}
]]>
     </example>
     </rule>
	 
	     <rule name="SystemPrintln"
    		since="2.1"
         message="System.out.print is used"
         class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#SystemPrintln">
     <description>
System.(out|err).print is used, consider using a logger.
     </description>
     <priority>2</priority>
     <properties>
         <property name="xpath">
             <value>
                 <![CDATA[
//Name[
    starts-with(@Image, 'System.out.print')
    or
    starts-with(@Image, 'System.err.print')
    ]
                ]]>
             </value>
         </property>
     </properties>
     <example>
 <![CDATA[
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    public void testA () {
        System.out.println("Entering test");
        // Better use this
        log.fine("Entering test");
    }
}
]]>
     </example>
     </rule>
	 
	     <rule  name="AvoidPrintStackTrace"
    		  since="3.2"
           message="Avoid printStackTrace(); use a logger call instead."
           class="net.sourceforge.pmd.rules.XPathRule"
		   externalInfoUrl="http://pmd.sourceforge.net/rules/logging-java.html#AvoidPrintStackTrace">
           <description>
Avoid printStackTrace(); use a logger call instead.
           </description>
           <priority>2</priority>
           <properties>
             <property name="xpath">
             <value>
<![CDATA[
//PrimaryExpression
 [PrimaryPrefix/Name[contains(@Image,'printStackTrace')]]
 [PrimarySuffix[not(boolean(Arguments/ArgumentList/Expression))]]
]]>
             </value>
             </property>
           </properties>
           <example>
<![CDATA[
class Foo {
 void bar() {
  try {
   // do something
  } catch (Exception e) {
   e.printStackTrace();
  }
 }
}
]]>
           </example>
    </rule>
	
	<!-- rules adapted from the PMD (4.2.5) 'migrating.xml' ruleset -->
	<rule name="ReplaceVectorWithList"
  since="3.4"
  message="Consider replacing this Vector with the newer java.util.List"
  class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#ReplaceVectorWithList">
  <description>
  Consider replacing Vector usages with the newer e.g. java.util.ArrayList if expensive threadsafe operation is not required.
  </description>
  <priority>3</priority>
  <properties>
    <property name="xpath">
    <value>
<![CDATA[
//Type/ReferenceType/ClassOrInterfaceType[@Image='Vector']
 ]]>
    </value>
    </property>
  </properties>
  <example>
<![CDATA[
public class Foo {
 void bar() {
    Vector v = new Vector();
 }
}
]]>
  </example>
</rule>


    <rule name="ReplaceHashtableWithMap"
      since="3.4"
      message="Consider replacing this Hashtable with the newer java.util.Map"
      class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#ReplaceHashtableWithMap">
      <description>
      Consider replacing this Hashtable with the newer java.util.Map
      </description>
      <priority>3</priority>
      <properties>
        <property name="xpath">
        <value>
    <![CDATA[
//Type/ReferenceType/ClassOrInterfaceType[@Image='Hashtable']
     ]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
    public class Foo {
     void bar() {
        Hashtable h = new Hashtable();
     }
    }
    ]]>
      </example>
    </rule>
	
	    <rule name="ReplaceEnumerationWithIterator"
      since="3.4"
      message="Consider replacing this Enumeration with the newer java.util.Iterator"
      class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#ReplaceEnumerationWithIterator">
      <description>
      Consider replacing this Enumeration with the newer java.util.Iterator
      </description>
      <priority>4</priority>
      <properties>
        <property name="xpath">
        <value>
    <![CDATA[
//ImplementsList/ClassOrInterfaceType[@Image='Enumeration']
     ]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
public class Foo implements Enumeration {
    private int x = 42;
    public boolean hasMoreElements() {
        return true;
    }
    public Object nextElement() {
        return String.valueOf(i++);
    }
}
    ]]>
      </example>
    </rule>
	
	
    <rule name="IntegerInstantiation"
          since="3.5"
          message="Avoid instantiating Integer objects. Call Integer.valueOf() instead."
	  class="net.sourceforge.pmd.rules.XPathRule"
      externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#IntegerInstantiation">
      <description>In JDK 1.5, calling new Integer() causes memory allocation.  Integer.valueOf() is more memory friendly.</description>
      <priority>2</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//PrimaryPrefix
 /AllocationExpression
  [not (ArrayDimsAndInits)
   and (ClassOrInterfaceType/@Image='Integer'
    or ClassOrInterfaceType/@Image='java.lang.Integer')]
                  ]]>
              </value>
          </property>
      </properties>
      <example>
  <![CDATA[
public class Foo {
 private Integer i = new Integer(0); // change to Integer i = Integer.valueOf(0);
}
   ]]>
      </example>
    </rule>
	<rule name="ByteInstantiation"
	       since="4.0"
          message="Avoid instantiating Byte objects. Call Byte.valueOf() instead"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#ByteInstantiation">
          <description>
              In JDK 1.5, calling new Byte() causes memory allocation. Byte.valueOf() is more memory friendly.
          </description>
          <priority>2</priority>
      <properties>
          <property name="xpath">
          <value>
          <![CDATA[
//PrimaryPrefix/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Byte'
or ClassOrInterfaceType/@Image='java.lang.Byte')]
          ]]>
          </value>
        </property>
     </properties>
     <example>
<![CDATA[
public class Foo {
private Byte i = new Byte(0); // change to Byte i =
Byte.valueOf(0);
}
]]>
     </example>
</rule>

    <rule name="ShortInstantiation"
          since="4.0"
          message="Avoid instantiating Short objects. Call Short.valueOf() instead"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#ShortInstantiation">
          <description>In JDK 1.5, calling new Short() causes memory allocation. Short.valueOf() is more memory friendly.
          </description>
          <priority>2</priority>
          <properties>
              <property name="xpath">
          <value>
<![CDATA[
//PrimaryPrefix
/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Short'
or ClassOrInterfaceType/@Image='java.lang.Short')]
]]>
          </value>
              </property>
          </properties>
          <example>
<![CDATA[
public class Foo {
private Short i = new Short(0); // change to Short i =
Short.valueOf(0);
}
]]>
          </example>
</rule>

<rule name="LongInstantiation"
   since="4.0"
	message="Avoid instantiating Long objects.Call Long.valueOf() instead"
    class="net.sourceforge.pmd.rules.XPathRule"
	externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#LongInstantiation">
    <description>In JDK 1.5, calling new Long() causes memory allocation. Long.valueOf() is more memory friendly.</description>
    <priority>2</priority>
    <properties>
    <property name="xpath">
    <value>
<![CDATA[
//PrimaryPrefix
/AllocationExpression
[not (ArrayDimsAndInits)
and (ClassOrInterfaceType/@Image='Long'
or ClassOrInterfaceType/@Image='java.lang.Long')]
]]>
    </value>
    </property>
    </properties>
    <example>
<![CDATA[
public class Foo {
private Long i = new Long(0); // change to Long i =
Long.valueOf(0);
}
]]>
    </example>
  </rule>
  
  
    <rule name="JUnit4TestShouldUseBeforeAnnotation"
          since="4.0"
          message="JUnit 4 tests that set up tests should use the @Before annotation"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#JUnit4TestShouldUseBeforeAnnotation">
      <description>
In JUnit 3, the setUp method was used to set up all data entities required in running tests. JUnit 4 skips the setUp method 
and executes all methods annotated with @Before before all tests
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration[MethodDeclaration/MethodDeclarator[@Image='setUp']]
[count(Annotation/MarkerAnnotation/Name[@Image='Before'])=0]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class MyTest {
    public void setUp() {
        bad();
    }
}
public class MyTest2 {
    @Before public void setUp() {
        good();
    }
}
]]>
      </example>
    </rule>
    <rule name="JUnit4TestShouldUseAfterAnnotation"
          since="4.0"
          message="JUnit 4 tests that clean up tests should use the @After annotation"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#JUnit4TestShouldUseAfterAnnotation">
      <description>
In JUnit 3, the tearDown method was used to clean up all data entities required in running tests. JUnit 4 skips the tearDown method 
and executes all methods annotated with @After after running each test
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration[MethodDeclaration/MethodDeclarator[@Image='tearDown']]
[count(Annotation/MarkerAnnotation/Name[@Image='After'])=0]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class MyTest {
    public void tearDown() {
        bad();
    }
}
public class MyTest2 {
    @After public void tearDown() {
        good();
    }
}
]]>
      </example>
    </rule>
    <rule name="JUnit4TestShouldUseTestAnnotation"
          since="4.0"
          message="JUnit 4 tests that execute tests should use the @Test annotation"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#JUnit4TestShouldUseTestAnnotation">
      <description>
In JUnit 3, the framework executed all methods which started with the word test as a unit test. In JUnit 4, only methods annotated
with the @Test annotation are executed.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration[MethodDeclaration/MethodDeclarator[starts-with(@Image,'test')]]
[count(Annotation//Name[@Image='Test'])=0]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class MyTest {
    public void testBad() {
        doSomething();
    }

	@Test
    public void testGood() {
        doSomething();
    }
}
]]>
      </example>
    </rule>
    <rule name="JUnit4SuitesShouldUseSuiteAnnotation"
          since="4.0"
          message="JUnit 4 indicates test suites via annotations, not the suite method."
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#JUnit4SuitesShouldUseSuiteAnnotation">
      <description>
In JUnit 3, test suites are indicated by the suite() method. In JUnit 4, suites are indicated
through the @RunWith(Suite.class) annotation.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration[MethodDeclaration/MethodDeclarator[@Image='suite']]
[MethodDeclaration/ResultType/Type/ReferenceType/ClassOrInterfaceType[@Image='Test' or @Image = 'junit.framework.Test']]
[not(MethodDeclaration/Block//ClassOrInterfaceType[@Image='JUnit4TestAdapter'])]
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class BadExample extends TestCase{

    public static Test suite(){
    	return new Suite();
    }
}

@RunWith(Suite.class)
@SuiteClasses( { TestOne.class, TestTwo.class })
public class GoodTest {
}]]>
      </example>
    </rule>
    
    <rule name="JUnitUseExpected"
          since="4.0"
          message="In JUnit4, use the @Test(expected) annotation to denote tests that should throw exceptions"
          class="net.sourceforge.pmd.rules.migration.JUnitUseExpected"
          externalInfoUrl="http://pmd.sourceforge.net/rules/migrating.html#JUnitUseExpected">
      <description>
      </description>
        <priority>3</priority>
      <example>
<![CDATA[
public class MyTest {
	@Test
    public void testBad() {
        try {
            doSomething();
            fail("should have thrown an exception");
        } catch (Exception e) {
        }
    }

	@Test(expected=Exception.class)
    public void testGood() {
        doSomething();
    }
}
]]>
      </example>
    </rule>
	
	
	<!-- rules adapted from the PMD (4.2.5) 'naming.xml' ruleset -->
	
	  <rule name="ShortVariable"
  		  since="0.3"
        message="Avoid variables with short names like {0}"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#ShortVariable">
    <description>
Detects when a field, local, or parameter has a very short name.
    </description>
    <priority>5</priority>
      <properties>
          <property name="xpath" pluginname="true">
              <value>
                  <![CDATA[
//VariableDeclaratorId[string-length(@Image) < 3]
 [not(ancestor::ForInit)]
 [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
 [not(@Image = 'in' or @Image = 'id')]
                  ]]>
              </value>
          </property>
      </properties>
    <example>
<![CDATA[
public class Something {
  private int q = 15; // VIOLATION - Field
  public static void main( String as[] ) {  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for (int i = 0; i < 10; i++) { // Not a Violation (inside FOR)
      r += q;
    }
  }
}
]]>
    </example>
  </rule>
  
  
  <rule name="LongVariable"
  		  since="0.3"
        message="Avoid excessively long variable names like {0}"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#LongVariable">
    <description>
Detects when a field, formal or local variable is declared with a long name.
    </description>
      <priority>5</priority>
      <properties>
          <property name="minimum" description="The variable length reporting threshold" value="36"/>
          <property name="xpath" pluginname="true">
              <value>
                  <![CDATA[
//VariableDeclaratorId[string-length(@Image) > $minimum]
                  ]]>
              </value>
          </property>
      </properties>
    <example>
<![CDATA[
public class Something {
  int reallyLongIntName = -3;  // VIOLATION - Field
  public static void main( String argumentsList[] ) { // VIOLATION - Formal
    int otherReallyLongName = -5; // VIOLATION - Local
    for (int interestingIntIndex = 0;  // VIOLATION - For
             interestingIntIndex < 10;
             interestingIntIndex ++ ) {
    }
}
]]>
    </example>
  </rule>

  <rule name="ShortMethodName"
  		  since="0.3"
        message="Avoid using short method names"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#ShortMethodName">
     <description>
Detects when very short method names are used.
     </description>
      <priority>5</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//MethodDeclarator[string-length(@Image) < 3]
                  ]]>
              </value>
          </property>
      </properties>
     <example>
<![CDATA[
public class ShortMethod {
  public void a( int i ) { // Violation
  }
}
]]>
     </example>
  </rule>


    <rule name="VariableNamingConventions"
    since="1.2"
    message="{0} variable {1} should begin with {2}"
    class="net.sourceforge.pmd.rules.VariableNamingConventions"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#VariableNamingConventions">
        <description>
A variable naming conventions rule - customize this to your liking.  Currently, it
 checks for final variables that should be fully capitalized and non-final variables
 that should not include underscores.
        </description>
        <priority>3</priority>
        <properties>
            <property name="staticPrefix" description="A prefix for static variables" value=""/>
            <property name="staticSuffix" description="A suffix for static variables" value=""/>
            <property name="memberPrefix" description="A prefix for member variables" value=""/>
            <property name="memberSuffix" description="A suffix for member variables" value=""/>
        </properties>
        <example>
<![CDATA[
public class Foo {
 public static final int MY_NUM = 0;
 public String myTest = "";
 DataModule dmTest = new DataModule();
}
]]>
        </example>
    </rule>

    <rule name="MethodNamingConventions"
    			  since="1.2"
              message="Method name does not begin with a lower case character."
              class="net.sourceforge.pmd.rules.MethodNamingConventions"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#MethodNamingConventions">
          <description>
Method names should always begin with a lower case character, and should not contain underscores.
          </description>
          <priority>2</priority>
          <example>
<![CDATA[
public class Foo {
 public void fooStuff() {
 }
}
]]>
          </example>
        </rule>

    <rule name="ClassNamingConventions"
    		 since="1.2"
          message="Class names should begin with an uppercase character"
          class="net.sourceforge.pmd.rules.ClassNamingConventions"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#ClassNamingConventions">
      <description>
Class names should always begin with an upper case character.
      </description>
      <priority>2</priority>
      <example>
<![CDATA[
public class Foo {}
]]>
      </example>
    </rule>

	<!--
    <rule name="AbstractNaming"
    		 since="1.4"
          message="Abstract classes should be named 'AbstractXXX'"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#AbstractNaming">
       <description>
Abstract classes should be named 'AbstractXXX'.
       </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true' and @Interface='false']
 [not (starts-with(@Image,'Abstract'))]
                    ]]>
                </value>
            </property>
        </properties>
       <example>
<![CDATA[
public abstract class Foo { // should be AbstractFoo
}
]]>
       </example>
    </rule>
	-->

    <rule name="AvoidDollarSigns"
    		  since="1.5"
           message="Avoid using dollar signs in variable/method/class/interface names"
           class="net.sourceforge.pmd.rules.naming.AvoidDollarSigns"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#AvoidDollarSigns">
       <description>
Avoid using dollar signs in variable/method/class/interface names.
       </description>
         <priority>1</priority>
       <example>
   <![CDATA[
 public class Fo$o {  // yikes!
 }
   ]]>
       </example>
     </rule>

    <rule name="MethodWithSameNameAsEnclosingClass"
    		 since="1.5"
          message="Classes should not have non-constructor methods with the same name as the class"
          class="net.sourceforge.pmd.rules.MethodWithSameNameAsEnclosingClass"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#MethodWithSameNameAsEnclosingClass">
       <description>
Non-constructor methods should not have the same name as the enclosing class.
       </description>
        <priority>2</priority>
       <example>
    <![CDATA[
public class MyClass {
 // this is bad because it is a method
 public void MyClass() {}
 // this is OK because it is a constructor
 public MyClass() {}
}
    ]]>
       </example>
     </rule>

    <rule name="SuspiciousHashcodeMethodName"
    		 since="1.5"
          message="The method name and return type are suspiciously close to hashCode()"
          class="net.sourceforge.pmd.rules.naming.SuspiciousHashcodeMethodName"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#SuspiciousHashcodeMethodName">
       <description>
The method name and return type are suspiciously close to hashCode(), which
may mean you are intending to override the hashCode() method.
       </description>
        <priority>3</priority>
       <example>
    <![CDATA[
public class Foo {
 public int hashcode() {
 // oops, this probably was supposed to be hashCode
 }
}
    ]]>
       </example>
     </rule>

    <rule name="SuspiciousConstantFieldName"
    		 since="2.0"
          message="The field name indicates a constant but its modifiers do not"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#SuspiciousConstantFieldName">
       <description>
A field name is all in uppercase characters, which in Sun's Java naming
conventions indicate a constant. However, the field is not final.
       </description>
       <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
 ]]>
                </value>
            </property>
        </properties>
       <example>
    <![CDATA[
public class Foo {
 // this is bad, since someone could accidentally
 // do PI = 2.71828; which is actualy e
 // final double PI = 3.16; is ok
 double PI = 3.16;
}
    ]]>
       </example>
     </rule>

    <rule
        name="SuspiciousEqualsMethodName"
        since="2.0"
        message="The method name and parameter number are suspiciously close to equals(Object)"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#SuspiciousEqualsMethodName">
        <description>
The method name and parameter number are suspiciously close to
equals(Object), which may mean you are intending to override the equals(Object)
method.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
        <![CDATA[
//MethodDeclarator[
(
@Image = 'equals'
  and count(FormalParameters/*) = 1
  and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
   [@Image = 'Object' or @Image = 'java.lang.Object'])
)
or
@Image='equal'
 and count(FormalParameters/*) = 1
 and (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
  [@Image = 'Object' or @Image = 'java.lang.Object'])

]
        ]]>
                    </value>
                 </property>
              </properties>
        <example>
        <![CDATA[
public class Foo {
 public int equals(Object o) {
 // oops, this probably was supposed to be boolean equals
 }
 public boolean equals(String s) {
 // oops, this probably was supposed to be equals(Object)
 }
}
        ]]>
        </example>
    </rule>

    <rule name="AvoidFieldNameMatchingTypeName"
    		 since="3.0"
          message="It is somewhat confusing to have a field name matching the declaring class name"
          class="net.sourceforge.pmd.rules.AvoidFieldNameMatchingTypeName"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#AvoidFieldNameMatchingTypeName">
      <description>
It is somewhat confusing to have a field name matching the declaring class name.
This probably means that type and or field names could be more precise.
      </description>
        <priority>3</priority>
      <example>
<![CDATA[
public class Foo extends Bar {
 // There's probably a better name for foo
 int foo;
}
]]>
      </example>
    </rule>

    <rule name="AvoidFieldNameMatchingMethodName"
    		 since="3.0"
          message="It is somewhat confusing to have a field name with the same name as a method"
          class="net.sourceforge.pmd.rules.AvoidFieldNameMatchingMethodName"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#AvoidFieldNameMatchingMethodName">
      <description>
It is somewhat confusing to have a field name with the same name as a method.
While this is totally legal, having information (field) and actions (method) is
not clear naming.
      </description>
        <priority>3</priority>
      <example>
<![CDATA[
public class Foo {
	Object bar;
	// bar is data or an action or both?
	void bar() {
	}
}
]]>
      </example>
    </rule>



    <rule name="NoPackage"
        since="3.3"
        message="All classes and interfaces must belong to a named package"
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#NoPackage">
    <description>
Detects when a class or interface does not have a package definition.
    </description>
    <priority>2</priority>
      <properties>
          <property name="xpath" pluginname="true">
              <value>
                  <![CDATA[
//ClassOrInterfaceDeclaration[count(preceding::PackageDeclaration) = 0]
                  ]]>
              </value>
          </property>
      </properties>
    <example>
<![CDATA[
// no package declaration
public class ClassInDefaultPackage {
}
]]>
    </example>
  </rule>

    <rule name="PackageCase"
            since="3.3"
            message="Package name contains upper case characters"
            class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#PackageCase">
        <description>
    Detects when a package definition contains upper case characters.
        </description>
        <priority>2</priority>
          <properties>
              <property name="xpath" pluginname="true">
                  <value>
                      <![CDATA[
//PackageDeclaration/Name[lower-case(@Image)!=@Image]
                      ]]>
                  </value>
              </property>
          </properties>
        <example>
    <![CDATA[
package com.MyCompany;  // <- should be lower case name
public class SomeClass {
}
    ]]>
        </example>
      </rule>

	<!--
    <rule name="MisleadingVariableName"
          since="3.4"
          message="Avoid naming non-fields with the prefix 'm_'"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#MisleadingVariableName">
      <description>
Detects when a non-field has a name starting with 'm_'.  This usually
indicates a field and thus is confusing.
      </description>
      <priority>3</priority>
        <properties>
            <property name="xpath" pluginname="true">
                <value>
                    <![CDATA[
//VariableDeclaratorId
[starts-with(@Image, 'm_')]
[not (../../../FieldDeclaration)]
                    ]]>
                </value>
            </property>
        </properties>
      <example>
  <![CDATA[
  public class Foo {
    private int m_foo; // OK
    public void bar(String m_baz) {  // Bad
      int m_boz = 42; // Bad
    }
  }
  ]]>
      </example>
    </rule>
	-->

    <rule name="BooleanGetMethodName"
        since="4.0"
        message="A 'getX()' method which returns a boolean should be named 'isX()'"
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#BooleanGetMethodName">
        <description>
Looks for methods named 'getX()' with 'boolean' as the return type. The convention
is to name these methods 'isX()'.
        </description>
        <priority>5</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[
MethodDeclarator[count(FormalParameters/FormalParameter) = 0 or $checkParameterizedMethods = 'true']
                [starts-with(@Image, 'get')]
and
ResultType/Type/PrimitiveType[@Image = 'boolean']
]
]]>
                </value>
            </property>
            <property name="checkParameterizedMethods">
                <value>false</value>
            </property>
        </properties>
        <example>
            <![CDATA[
public boolean getFoo(); // bad
public boolean isFoo(); // ok
public boolean getFoo(boolean bar); // ok, unless checkParameterizedMethods=true
     ]]></example>
    </rule>

	
	<!-- rules adapted from PMD (4.2.5) 'optimizations.xml' ruleset -->

	
    <rule name="LocalVariableCouldBeFinal"
    	 since="2.2"
	    message="Local variable ''{0}'' could be declared final"
          class="net.sourceforge.pmd.rules.optimization.LocalVariableCouldBeFinal"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#LocalVariableCouldBeFinal">
      <description>
A local variable assigned only once can be declared final.
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
public class Bar {
 public void foo () {
  String a = "a"; //if a will not be assigned again it is better to do this:
  final String b = "b";
 }
}
  ]]>
      </example>
      </rule>

    <rule name="MethodArgumentCouldBeFinal"
    		 since="2.2"
          message="Parameter ''{0}'' is not assigned and could be declared final"
          class="net.sourceforge.pmd.rules.optimization.MethodArgumentCouldBeFinal"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#MethodArgumentCouldBeFinal">
      <description>
A method argument that is never assigned can be declared final.
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
public void foo (String param) {
  // do stuff with param never assigning it
  // better: public void foo (final String param) {
}
  ]]>
      </example>
      </rule>

	<!--
		pohl: this is much too common to restrict it by a general rule...
		
  <rule name="AvoidInstantiatingObjectsInLoops"
  		  since="2.2"
        message="Avoid instantiating new objects inside loops"
        class="net.sourceforge.pmd.rules.optimization.AvoidInstantiatingObjectsInLoops"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#AvoidInstantiatingObjectsInLoops">
    <description>
Detects when a new object is created inside a loop
    </description>
      <priority>5</priority>
    <example>
<![CDATA[
public class Something {
  public static void main( String as[] ) {  
    for (int i = 0; i < 10; i++) {
      Foo f = new Foo(); //Avoid this whenever you can it's really expensive
    }
  }
}
]]>
    </example>
  </rule>
  
    <rule name="UseArrayListInsteadOfVector"
    		 since="3.0"
          message="Use ArrayList instead of Vector"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#UseArrayListInsteadOfVector">
      <description>
ArrayList is a much better Collection implementation than Vector.
      </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//AllocationExpression
 /ClassOrInterfaceType[@Image='Vector' or @Image='java.util.Vector']
]]>
              </value>
          </property>
      </properties>
      <example>
<![CDATA[
public class SimpleTest extends TestCase {
 public void testX() {
  Collection c = new Vector();
  // This achieves the same with much better performance
  // Collection c = new ArrayList();
 }
}
]]>
          </example>
    </rule>
	-->

    <rule name="SimplifyStartsWith"
    		 since="3.1"
          message="This call to String.startsWith can be rewritten using String.charAt(0)"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#SimplifyStartsWith">
      <description>
Since it passes in a literal of length 1, this call to String.startsWith can be rewritten using String.charAt(0) to save some time.
      </description>
      <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//PrimaryExpression
 [PrimaryPrefix/Name
  [ends-with(@Image, '.startsWith')]]
 [PrimarySuffix/Arguments/ArgumentList
  /Expression/PrimaryExpression/PrimaryPrefix
  /Literal
   [string-length(@Image)=3]
   [starts-with(@Image, '"')]
   [ends-with(@Image, '"')]
 ]
 ]]>
            </value>
        </property>
    </properties>
      <example>
  <![CDATA[
public class Foo {
  boolean checkIt(String x) {
      return x.startsWith("a");
  }
}
]]>
      </example>
    </rule>

    <rule name="UseStringBufferForStringAppends"
    		 since="3.1"
          message="Prefer StringBuffer over += for concatenating strings"
          class="net.sourceforge.pmd.rules.optimization.UseStringBufferForStringAppends"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#UseStringBufferForStringAppends">
           <description>
Finds usages of += for appending strings.
           </description>
            <priority>3</priority>
           <example>
      <![CDATA[
public class Foo {
 void bar() {
  String a;
  a = "foo";
  a += " bar";
  // better would be:
  // StringBuffer a = new StringBuffer("foo");
  // a.append(" bar);
 }
}
      ]]>
           </example>
        </rule>

  <rule name="UseArraysAsList"
     since="3.5"
     message="Use asList instead of tight loops"
      class="net.sourceforge.pmd.rules.XPathRule"
      externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#UseArraysAsList">
     <description>
   The java.util.Arrays class has a "asList" method that
   should be used when you want to create a new List from
   an array of objects. It is faster than executing a loop to
   copy all the elements of the array one by one
     </description>
     <priority>3</priority>
     <properties>
       <property name="xpath">
       <value>
   <![CDATA[
//Statement[
    (ForStatement) and (count(.//IfStatement)=0)
   ]
   //StatementExpression[
    PrimaryExpression/PrimaryPrefix/Name[
	 substring-before(@Image,'.add') = ancestor::MethodDeclaration//LocalVariableDeclaration[
      ./Type//ClassOrInterfaceType[
       @Image = 'Collection' or 
       @Image = 'List' or @Image='ArrayList'
      ]
     ]
     /VariableDeclarator/VariableDeclaratorId[
      count(..//AllocationExpression/ClassOrInterfaceType[
       @Image="ArrayList"
      ]
      )=1
     ]/@Image
    ]
   and
   PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
   [@Image = ancestor::MethodDeclaration//LocalVariableDeclaration
   [@Array="true"]/VariableDeclarator/VariableDeclaratorId/@Image]
   /../..[count(.//PrimarySuffix)
   =1]/PrimarySuffix/Expression/PrimaryExpression/PrimaryPrefix
   /Name
   ]
   ]]>
       </value>
       </property>
     </properties>
     <example>
   <![CDATA[
   public class Test {
    public void foo(Integer[] ints) {
    // could just use Arrays.asList(ints)
     List l= new ArrayList(10);
     for (int i=0; i< 100; i++) {
      l.add(ints[i]);
     }
     for (int i=0; i< 100; i++) {
      l.add(a[i].toString()); // won't trigger the rule
     }
    }
   }
   ]]>
     </example>
   </rule>


    <rule name="AvoidArrayLoops"
      since="3.5"
      message="System.arraycopy is more efficient"
      class="net.sourceforge.pmd.rules.XPathRule"
      externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#AvoidArrayLoops">
      <description>
    Instead of copying data between two arrays, use
    System.arraycopy method
      </description>
      <priority>3</priority>
      <properties>
        <property name="xpath">
        <value>
    <![CDATA[
//Statement[(ForStatement or WhileStatement) and
count(*//AssignmentOperator[@Image = '='])=1
and
*/Statement
[
./Block/BlockStatement/Statement/StatementExpression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix/Expression
[(PrimaryExpression or AdditiveExpression) and count
(.//PrimaryPrefix/Name)=1]//PrimaryPrefix/Name/@Image
and
./Block/BlockStatement/Statement/StatementExpression/Expression/PrimaryExpression
/PrimaryPrefix/Name/../../PrimarySuffix[count
(..//PrimarySuffix)=1]/Expression[(PrimaryExpression
or AdditiveExpression) and count(.//PrimaryPrefix/Name)=1]
//PrimaryPrefix/Name/@Image
]]
    ]]>
        </value>
        </property>
      </properties>
      <example>
    <![CDATA[
public class Test {
 public void bar() {
  int[] a = new int[10];
  int[] b = new int[10];
  for (int i=0;i<10;i++) {
   b[i]=a[i];
  }
 }
}
            // this will trigger the rule
            for (int i=0;i<10;i++) {
             b[i]=a[c[i]];
            }

        }
    }
    ]]>
      </example>
    </rule>

    <rule name="UnnecessaryWrapperObjectCreation"
          since="3.8"
          message="Unnecessary wrapper object creation"
          class="net.sourceforge.pmd.rules.optimization.UnnecessaryWrapperObjectCreation"
          externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#UnnecessaryWrapperObjectCreation">
      <description>
Parsing method should be called directy instead.
      </description>
      <priority>3</priority>
      <example>
<![CDATA[
public int convert(String s) {
  int i, i2;

  i = Integer.valueOf(s).intValue(); // this wastes an object
  i = Integer.parseInt(s); // this is better

  i2 = Integer.valueOf(i).intValue(); // this wastes an object
  i2 = i; // this is better

  String s3 = Integer.valueOf(i2).toString(); // this wastes an object
  s3 = Integer.toString(i2); // this is better

  return i2;
}
]]>
          </example>
    </rule>

    <rule name="AddEmptyString"
        since="4.0"
        message="Do not add empty strings"
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/optimizations.html#AddEmptyString">
        <description>
Finds empty string literals which are being added. This is an inefficient way 
to convert any type to a String.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[ 
//AdditiveExpression/PrimaryExpression/PrimaryPrefix/Literal[@Image='""']
                ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[ 
        String s = "" + 123; // bad 
        String t = Integer.toString(456); // ok 
            ]]>
        </example>
    </rule>


    <!--
    other optimization should be like avoiding
    "" + int
    or "" + (int) i
    and String.valueOf(int)
    
    and using Integer.toString(int)

    IntegerToStringShouldBeUsed
    LongToStringShouldBeUsed
    BooleanToStringShouldBeUsed    
    -->
	
	
	<!-- rules adapted from PMD (4.2.5) 'strictexception.xml' -->
	
   <rule name="AvoidCatchingThrowable"
   		since="1.2"
         message="A catch statement should never catch throwable since it includes errors."
          class="net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidCatchingThrowable">
      <description>
This is dangerous because it casts too wide a net; it can catch things like OutOfMemoryError.
      </description>
      <priority>1</priority>
      <example>
                <![CDATA[
public class Foo {
 public void bar() {
  try {
   // do something
  } catch (Throwable th) {  //Should not catch throwable
   th.printStackTrace();
  }
 }
}
                ]]>
      </example>
    </rule>

	<!-- covered by SignatureDeclareThrowsException below 
   <rule name="SignatureDeclareThrowsException"
   		since="1.2"
         message="A method/constructor shouldn't explicitly throw java.lang.Exception"
          class="net.sourceforge.pmd.rules.strictexception.ExceptionSignatureDeclaration"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#SignatureDeclareThrowsException">
      <description>
It is unclear which exceptions that can be thrown from the methods.
It might be difficult to document and understand the vague interfaces.
Use either a class derived from RuntimeException or a checked exception.
      </description>
      <priority>2</priority>
      <example>
                <![CDATA[
public void methodThrowingException() throws Exception {
}
                ]]>
      </example>
    </rule>
	-->
	
    <rule name="ExceptionAsFlowControl"
    		 since="1.8"
          message="Avoid using exceptions as flow control."
          class="net.sourceforge.pmd.rules.design.ExceptionAsFlowControl"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#ExceptionAsFlowControl">
      <description>
          Using Exceptions as flow control leads to GOTOish code and obscures true exceptions when debugging.
      </description>
        <priority>2</priority>
      <example>
  <![CDATA[
public class Foo {
 void bar() {
  try {
   try {
   } catch (Exception e) {
    throw new WrapperException(e);
    // this is essentially a GOTO to the WrapperException catch block
   }
  } catch (WrapperException e) {
   // do some more stuff
  }
 }
}
  ]]>
      </example>
    </rule>

<rule name="AvoidCatchingNPE"
	 since="1.8"
    message="Avoid catching NullPointerException; consider removing the cause of the NPE."
    class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidCatchingNPE">
    <description>
      Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.
    </description>
    <priority>3</priority>
    <properties>
      <property name="xpath">
        <value>
            <![CDATA[
//CatchStatement/FormalParameter/Type
 /ReferenceType/ClassOrInterfaceType[@Image='NullPointerException']
 ]]>
        </value>
      </property>
    </properties>
    <example>  <![CDATA[
public class Foo {
 void bar() {
  try {
   // do something
   }  catch (NullPointerException npe) {
  }
 }
}
]]>
    </example>
  </rule>

  <rule name="AvoidThrowingRawExceptionTypes"
      since="1.8"
      message="Avoid throwing raw exception types."
      class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidThrowingRawExceptionTypes">
    <description>
Avoid throwing certain exception types. Rather than throw a raw RuntimeException, Throwable,
Exception, or Error, use a subclassed exception or error instead.
    </description>
    <priority>1</priority>
    <properties>
      <property name="xpath">
        <value>
            <![CDATA[
//AllocationExpression
 /ClassOrInterfaceType[
 (@Image='Throwable' and count(//ImportDeclaration/Name[ends-with(@Image,'Throwable')]) = 0)
or
 (@Image='Exception' and count(//ImportDeclaration/Name[ends-with(@Image,'Exception')]) = 0)
or
 (@Image='Error'  and count(//ImportDeclaration/Name[ends-with(@Image,'Error')]) = 0)
or
( @Image='RuntimeException'  and count(//ImportDeclaration/Name[ends-with(@Image,'RuntimeException')]) = 0)
]
 ]]>
        </value>
      </property>
    </properties>
    <example>
      <![CDATA[
public class Foo {
public void bar() throws Exception {
  throw new Exception();
 }
}
]]>
    </example>
  </rule>

    <rule name="AvoidThrowingNullPointerException"
    	  since="1.8"
        message="Avoid throwing null pointer exceptions."
        class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidThrowingNullPointerException">
      <description>
Avoid throwing a NullPointerException - it's confusing because most people will assume that the
virtual machine threw it. Consider using an IllegalArgumentException instead; this will be
clearly seen as a programmer-initiated exception.
      </description>
      <priority>1</priority>
      <properties>
        <property name="xpath">
          <value>
              <![CDATA[
//AllocationExpression/ClassOrInterfaceType[@Image='NullPointerException']
   ]]>
          </value>
        </property>
      </properties>
      <example>
        <![CDATA[
public class Foo {
 void bar() {
  throw new NullPointerException();
 }
}
  ]]>
      </example>
    </rule>

  <rule name="AvoidRethrowingException"
    since="3.8"
    message="A catch statement that catches an exception only to rethrow it should be avoided."
    class="net.sourceforge.pmd.rules.XPathRule"
    externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidRethrowingException">
    <description>
     Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.
    </description>
    <priority>2</priority>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//CatchStatement[FormalParameter
 /VariableDeclaratorId/@Image = Block/BlockStatement/Statement
 /ThrowStatement/Expression/PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix/Name/@Image
 and count(Block/BlockStatement/Statement) <3]
 ]]>
            </value>
        </property>
    </properties>
    <example>  <![CDATA[
  public class Foo {
   void bar() {
    try {
    // do something
    }  catch (SomeException se) {
       throw se;
    }
   }
  }
  ]]>
    </example>
  </rule>

  <rule
    name="DoNotExtendJavaLangError"
    since="4.0"
    message="Exceptions should not extend java.lang.Error"
    class="net.sourceforge.pmd.rules.XPathRule"
    externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#DoNotExtendJavaLangError">
    <description>
      <![CDATA[
        Errors are system exceptions. Do not extend them.
      ]]>
    </description>
    <priority>3</priority>
    <properties>
      <property name="xpath">
        <value>
          <![CDATA[
//ClassOrInterfaceDeclaration/ExtendsList/ClassOrInterfaceType
  [@Image="Error" or @Image="java.lang.Error"]
          ]]>
        </value>
      </property>
    </properties>
    <example><![CDATA[
        public class Foo extends Error { }
    ]]></example>
  </rule>

	<rule	name="DoNotThrowExceptionInFinally"
	       since="4.2"
		    message="A throw statement in a finally block makes the control flow hard to understand."
		    class="net.sourceforge.pmd.rules.XPathRule"
		    externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#DoNotThrowExceptionInFinally">
    	<description>
			<![CDATA[
			      Throwing exception in a finally block is confusing. It may mask exception or a defect of the code,
			      it also render code cleanup uninstable.
			Note: This is a PMD implementation of the Lint4j rule "A throw in a finally block"
			]]>
		</description>
    	<priority>2</priority>
    	<properties>
			<property name="xpath">
			  <value>
			    <![CDATA[
//FinallyStatement[descendant::ThrowStatement]
			          ]]>
			  </value>
			</property>
		</properties>
    	<example>
    		<![CDATA[
				public class Foo 
				{
					public void bar()
					{
						try {
							// Here do some stuff
						}
						catch( Exception e) {
							// Handling the issue
						}
						finally 
						{
							// is this really a good idea ?
							throw new Exception();
						}
					}
				}
	    	]]>
    	</example>
    </rule>

  <rule name="AvoidThrowingNewInstanceOfSameException"
    since="4.2.5"
    message="A catch statement that catches an exception only to wrap it in a new instance of the same type of exception and throw it should be avoided"
    externalInfoUrl="http://pmd.sourceforge.net/rules/strictexception.html#AvoidThrowingNewInstanceOfSameException"
    class="net.sourceforge.pmd.rules.XPathRule">
    <description>
     Catch blocks that merely rethrow a caught exception wrapped inside a new instance of the same type only add to code size and runtime complexity.
    </description>
    <priority>3</priority>
    <properties>
    <property name="xpath">
      <value>
        <![CDATA[
//CatchStatement[
  count(Block/BlockStatement/Statement) = 1
  and
  FormalParameter/Type/ReferenceType/ClassOrInterfaceType/@Image = Block/BlockStatement/Statement/ThrowStatement/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType/@Image
  and
  count(Block/BlockStatement/Statement/ThrowStatement/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression) = 1
  and
  FormalParameter/VariableDeclaratorId = Block/BlockStatement/Statement/ThrowStatement/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
  ]
 ]]>
      </value>
    </property>
    </properties>    
    <example>  <![CDATA[
    public class Foo {
     void bar() {
      try {
       // do something
      }  catch (SomeException se) {
         // harmless comment      
           throw new SomeException(se);
      }
     }
    }
  ]]>
    </example>
  </rule>
  
  <!-- TODO missing: preserve stack trace in wrapper exception -->
  
  <!-- rules adapted from PMD (4.2.5) 'strings.xml' ruleset -->
  
  
	<!-- TODO: this rules probably has to be pimped 
	
		disabled for now. There are too many duplicated string concatenation which should not be put to constants...
		
    <rule name="AvoidDuplicateLiterals"
    	  since="1.0"
        message="The String literal {0} appears {1} times in this file; the first occurrence is on line {2}"
        class="net.sourceforge.pmd.rules.strings.AvoidDuplicateLiteralsRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#AvoidDuplicateLiterals">
    <description>
Code containing duplicate String literals can usually be improved by declaring the String as a constant field.
    </description>
        <priority>3</priority>
   <properties>
    <property name="threshold" description="The number of duplicate literals reporting threshold" value="3"/>
    <property name="skipAnnotations" description="Skip literals within Annotations" value="true"/>
    <property name="exceptionlist" description="Strings in that list are skipped"/>
    <property name="separator" description="Separator used in the exceptionlist" value=","/>
    <property name="exceptionfile" description="File containing strings to skip (one string per line), only used if exceptionlist is not set"/>
   </properties>
    <example>
<![CDATA[
public class Foo {
 private void bar() {
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
 }
 private void buz(String x) {}
}
]]>
    </example>
  </rule>

    <rule name="StringInstantiation"
    	  since="1.0"
        message="Avoid instantiating String objects; this is usually unnecessary."
        class="net.sourceforge.pmd.rules.strings.StringInstantiation"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#StringInstantiation">
    <description>
Avoid instantiating String objects; this is usually unnecessary.
    </description>
       <priority>2</priority>
    <example>
<![CDATA[
public class Foo {
 private String bar = new String("bar"); // just do a String bar = "bar";
}
]]>
    </example>
    </rule>
	-->
	
   <rule name="StringToString"
   	  since="1.0"
        message="Avoid calling toString() on String objects; this is unnecessary."
        class="net.sourceforge.pmd.rules.strings.StringToStringRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#StringToString">
    <description>
    Avoid calling toString() on String objects; this is unnecessary.
    </description>
       <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}
]]>
    </example>
    </rule>

    <rule name="InefficientStringBuffering"
   	  since="3.4"
        message="Avoid concatenating nonliterals in a StringBuffer constructor or append()."
        class="net.sourceforge.pmd.rules.strings.InefficientStringBuffering"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#InefficientStringBuffering">
    <description>
Avoid concatenating non literals in a StringBuffer constructor or append().
    </description>
       <priority>2</priority>
    <example>
<![CDATA[
public class Foo {
 void bar() {
  // Avoid this
  StringBuffer sb=new StringBuffer("tmp = "+System.getProperty("java.io.tmpdir"));
  // use instead something like this
  StringBuffer sb = new StringBuffer("tmp = ");
  sb.append(System.getProperty("java.io.tmpdir"));
 }
}
]]>
    </example>
    </rule>

    <rule name="UnnecessaryCaseChange"
          since="3.3"
          message="Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals()."
           class="net.sourceforge.pmd.rules.strings.UnnecessaryCaseChange"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#UnnecessaryCaseChange">
       <description>
Using equalsIgnoreCase() is faster than using toUpperCase/toLowerCase().equals()
       </description>
       <priority>3</priority>
       <example>
                 <![CDATA[
 public class Foo {
  public boolean bar(String buz) {
    // should be buz.equalsIgnoreCase("baz")
    return buz.toUpperCase().equals("baz");
    // another unnecessary toUpperCase()
    // return buz.toUpperCase().equalsIgnoreCase("baz");
  }
 }
                 ]]>
       </example>
     </rule>

    <rule name="UseStringBufferLength"
          since="3.4"
          message="This is an inefficient use of StringBuffer.toString; call StringBuffer.length instead."
          class="net.sourceforge.pmd.rules.strings.UseStringBufferLength"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#UseStringBufferLength">
      <description>
 Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("")
          or StringBuffer.toString().length() ==.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
 void bar() {
  StringBuffer sb = new StringBuffer();
  // this is bad
  if(sb.toString().equals("")) {}
  // this is good
  if(sb.length() == 0) {}
 }
}

  ]]>
      </example>
    </rule>


    <rule name="AppendCharacterWithChar"
        since="3.5"
        message="Avoid appending characters as strings in StringBuffer.append."
        class="net.sourceforge.pmd.rules.strings.AppendCharacterWithChar"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#AppendCharacterWithChar">
    <description>
Avoid concatenating characters as strings in StringBuffer.append.
    </description>
       <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
 void bar() {
  StringBuffer sb=new StringBuffer();
  // Avoid this
  sb.append("a");

  // use instead something like this
  StringBuffer sb=new StringBuffer();
  sb.append('a');
 }
}
]]>
    </example>
    </rule>

        <rule name="ConsecutiveLiteralAppends"
        since="3.5"
        message="StringBuffer.append is called {0} consecutive times with literal Strings. Use a single append with a single String."
        class="net.sourceforge.pmd.rules.strings.ConsecutiveLiteralAppends"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#ConsecutiveLiteralAppends">
    <description>
Consecutively calling StringBuffer.append with String literals
    </description>
        <priority>3</priority>
   <properties>
    <property name="threshold" description="The report threshold" value="1"/>
   </properties>
    <example>
<![CDATA[
public class Foo {
 private void bar() {
   StringBuffer buf = new StringBuffer();
   buf.append("Hello").append(" ").append("World"); //bad
   buf.append("Hello World");//good
 }
}
]]>
    </example>
  </rule>


    <rule name="UseIndexOfChar"
        since="3.5"
        message="String.indexOf(char) is faster than String.indexOf(String)."
        class="net.sourceforge.pmd.rules.strings.UseIndexOfChar"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#UseIndexOfChar">
    <description>
Use String.indexOf(char) when checking for the index of a single character; it executes faster.
    </description>
       <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
 void bar() {
  String s = "hello world";
  // avoid this
  if (s.indexOf("d") {}
  // instead do this
  if (s.indexOf('d') {}
 }
}
]]>
    </example>
    </rule>

    <rule name="InefficientEmptyStringCheck"
        since="3.6"
        message="String.trim().length()==0 is an inefficient way to validate an empty String."
        class="net.sourceforge.pmd.rules.strings.InefficientEmptyStringCheck"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#InefficientEmptyStringCheck">
    <description>
String.trim().length() is an inefficient way to check if a String is really empty, as it
creates a new String object just to check its size. Consider creating a static function that
loops through a string, checking Character.isWhitespace() on each character and returning
false if a non-whitespace character is found.
    </description>
       <priority>4</priority>
    <example>
<![CDATA[
public class Foo {
    void bar(String string) {
        if (string != null && string.trim().size() > 0) {
		    doSomething();
        }
    }
}
]]>
    </example>
    </rule>

    <rule name="InsufficientStringBufferDeclaration"
        since="3.6"
        message="StringBuffer constructor is initialized with size {0}, but has at least {1} characters appended."
        class="net.sourceforge.pmd.rules.strings.InsufficientStringBufferDeclaration"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#InsufficientStringBufferDeclaration">
    <description>
Failing to pre-size a StringBuffer properly could cause it to re-size many times
during runtime. This rule checks the characters that are actually passed into
StringBuffer.append(), but represents a best guess "worst case" scenario. An
empty StringBuffer constructor initializes the object to 16 characters. This default
is assumed if the length of the constructor can not be determined.
    </description>
       <priority>4</priority>
    <example>
<![CDATA[
public class Foo {
    void bar() {
        StringBuffer bad = new StringBuffer();
        bad.append("This is a long string, will exceed the default 16 characters");//bad
        StringBuffer good = new StringBuffer(41);
        good.append("This is a long string, which is pre-sized");//good
    }
}
]]>
    </example>
    </rule>

    <rule name="UselessStringValueOf"
          since="3.8"
          message="No need to call String.valueOf to append to a string."
          class="net.sourceforge.pmd.rules.strings.UselessStringValueOf"
          externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#UselessStringValueOf">
      <description>
No need to call String.valueOf to append to a string; just use the valueOf() argument directly.
      </description>
        <priority>3</priority>
      <example>
<![CDATA[
public String convert(int i) {
  String s;
  s = "a" + String.valueOf(i); // Bad
  s = "a" + i; // Better
  return s;
}
]]>
          </example>
    </rule>


<rule   name="StringBufferInstantiationWithChar"
        since="3.9"
        message="Do not instantiate a StringBuffer with a char"
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#StringBufferInstantiationWithChar">
    <description>
StringBuffer sb = new StringBuffer('c'); The
char will be converted into int to intialize
StringBuffer size.
    </description>
    <priority>2</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//AllocationExpression/ClassOrInterfaceType
[@Image='StringBuffer']
/../Arguments/ArgumentList/Expression/PrimaryExpression
/PrimaryPrefix/
Literal
  [starts-with(@Image, "'")]
  [ends-with(@Image, "'")]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
class Foo {
  StringBuffer sb1 = new StringBuffer('c'); //Bad
  StringBuffer sb2 = new StringBuffer("c"); //Better
}
]]>
    </example>
    </rule>

<rule   name="UseEqualsToCompareStrings"
        since="4.1"
        message="Use equals() to compare strings instead of ''=='' or ''!=''"
        class="net.sourceforge.pmd.rules.XPathRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#UseEqualsToCompareStrings">
    <description>
Using '==' or '!=' to compare strings only works if intern version is used on both sides
    </description>
    <priority>2</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//EqualityExpression/PrimaryExpression
[(PrimaryPrefix/Literal
   [starts-with(@Image, '"')]
   [ends-with(@Image, '"')]
and count(PrimarySuffix) = 0)]
]]>
            </value>
        </property>
    </properties>
    <example>
<![CDATA[
class Foo {
  boolean test(String s) {
    if (s == "one") return true; //Bad
    if ("two".equals(s)) return true; //Better
    return false;
  }
}
]]>
    </example>
    </rule>

	<rule   name="AvoidStringBufferField"
	      since="4.2"
        	message="StringBuffers can grow quite a lot, and so may become a source of memory leak (if the owning class has a long life time)."
        	class="net.sourceforge.pmd.rules.XPathRule"
        	externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#AvoidStringBufferField">
    <description>
		<![CDATA[
			StringBuffers can grow quite a lot, and so may become a source of memory leak (if the owning class has a long life time).
		]]>
    </description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[@Image = 'StringBuffer']
]]>
			</value>
		</property>
		</properties>
    	<example>
<![CDATA[
class Foo {
	private StringBuffer memoryLeak;
}
]]>
		</example>
	</rule>
	
	<!-- rules adapted from PMD (4.2.5) 'typeresolution.xml' ruleset -->
	
	
    <rule name="LooseCoupling"
   	  since="3.9"
          message="Avoid using implementation types like ''{0}''; use the interface instead"
          class="net.sourceforge.pmd.typeresolution.rules.LooseCoupling"
          typeResolution="true"
          externalInfoUrl="http://pmd.sourceforge.net/rules/typeresolution.html#LooseCoupling">
      <description>
Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead
      </description>
        <priority>2</priority>
      <example>
<![CDATA[
import java.util.ArrayList;
import java.util.HashSet;
public class Bar {
 // Use List instead
 private ArrayList list = new ArrayList();
 // Use Set instead
 public HashSet getFoo() {
  return new HashSet();
 }
}
  ]]>
      </example>
    </rule>

    <rule name="CloneMethodMustImplementCloneable"
   	  since="3.9"
        message="clone() method should be implemented only if implementing Cloneable interface"
        class="net.sourceforge.pmd.typeresolution.rules.CloneMethodMustImplementCloneable"
        typeResolution="true"
          externalInfoUrl="http://pmd.sourceforge.net/rules/typeresolution.html#CloneMethodMustImplementCloneable">
        <description>
The method clone() should only be implemented if the class implements the 
Cloneable interface with the exception of a final method that only throws 
CloneNotSupportedException. This version uses PMD's type resolution facilities, 
and can detect if the class implements or extends a Cloneable class
        </description>
        <priority>2</priority>
        <example>
            <![CDATA[
public class MyClass {
 public Object clone() throws CloneNotSupportedException {
  return foo;
 }
}
   ]]>
        </example>
    </rule>

  <rule name="UnusedImports"
   	  since="4.0"
        message="Avoid unused imports such as ''{0}''"
        class="net.sourceforge.pmd.typeresolution.rules.imports.UnusedImports"
        typeResolution="true"
          externalInfoUrl="http://pmd.sourceforge.net/rules/typeresolution.html#UnusedImports">
    <description>
    Avoid unused import statements. This rule will find unused on demand imports, i.e. import com.foo.*.
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
// this is bad
import java.io.*;
public class Foo {}
]]>
    </example>
    </rule>
    
    <rule name="SignatureDeclareThrowsException"
   	  since="4.0"
         message="A method/constructor shouldn't explicitly throw java.lang.Exception"
          class="net.sourceforge.pmd.typeresolution.rules.SignatureDeclareThrowsException"
          externalInfoUrl="http://pmd.sourceforge.net/rules/typeresolution.html#SignatureDeclareThrowsException"
          typeResolution="true">
      <description>
It is unclear which exceptions that can be thrown from the methods.
It might be difficult to document and understand the vague interfaces.
Use either a class derived from RuntimeException or a checked exception.

Junit classes are excluded.
      </description>
      <priority>2</priority>
      <properties>
          <property description="If true, all methods in a JUnit testcase may throw Exception" 
            name="IgnoreJUnitCompletely" value="true"/>
      </properties>
      <example>
      	<![CDATA[
public void methodThrowingException() throws Exception {
}
      	]]>
      </example>
    </rule> 
    

	<!-- rules adapted from PMD (4.2.5) 'unusedcode.xml' -->
	
	
  <rule name="UnusedPrivateField"
  		  since="0.1"
        message="Avoid unused private fields such as ''{0}''."
        class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/unusedcode.html#UnusedPrivateField">
    <description>
Detects when a private field is declared and/or assigned a value, but not used.
    </description>
      <priority>2</priority>
    <example>
<![CDATA[
public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}
]]>
    </example>
  </rule>

<rule name="UnusedLocalVariable"
		  since="0.1"
        message="Avoid unused local variables such as ''{0}''."
        class="net.sourceforge.pmd.rules.UnusedLocalVariableRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/unusedcode.html#UnusedLocalVariable">
    <description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
    <priority>2</priority>

    <example>
<![CDATA[
public class Foo {
 public void doSomething() {
  int i = 5; // Unused
 }
}
]]>
    </example>
  </rule>

    <rule name="UnusedPrivateMethod"
    	  since="0.7"
        message="Avoid unused private methods such as ''{0}''."
        class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/unusedcode.html#UnusedPrivateMethod">
    <description>
Unused Private Method detects when a private method is declared but is unused.
    </description>
        <priority>2</priority>
    <example>
<![CDATA[
public class Something {
 private void foo() {} // unused
}
]]>
    </example>
  </rule>


  <rule name="UnusedFormalParameter"
  		  since="0.8"
        message="Avoid unused {0} parameters such as ''{1}''."
        class="net.sourceforge.pmd.rules.UnusedFormalParameterRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/unusedcode.html#UnusedFormalParameter">
    <description>
Avoid passing parameters to methods or constructors and then not using those parameters.
    </description>
      <priority>3</priority>

    <example>
<![CDATA[
public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }
]]>
    </example>
  </rule>


</ruleset>
